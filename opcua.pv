(* -lib config.pvl *)

(******************************************************************************
   Formal model of the OPC-UA protocol v1.05.03 and v1.05.04 RC.
   Description of the protocol, threat model, security objectives and analysis
   results are in the companion technical report:
            "A Comprehensive Formal Security Analysis of OPC-UA"
   by [authors' names were redacted].
   See README.md for more information about how to run this file.
******************************************************************************)

free c : channel. (* channel under adversarial control *)


(**************** Term Algebra ****************)
(**********************************************)

(* Asymmetric keys *)
type skey.                 (* private key *)
const no_skey: skey.
type pkey.                 (* public  key *)
fun pk(skey): pkey.
const no_pkey: pkey.
type thumbprint.
fun h(pkey): thumbprint.
const no_print: thumbprint. (* when the tumbprint field is omitted *)

(* RSA asymmetric keys are used both for encryption *)
(* and signature, cf. Part 6: §6.1 & §6.7           *)
fun aenc(bitstring, pkey): bitstring.
reduc forall m: bitstring, k: skey;
       adec( aenc(m, pk(k)), k) = m.

(* RSA asymmetric keys are used also for signature *)
(* Cf. Part 6: § 6.1 & 6.7                         *)
(* ECC asymmetric keys are only used for signature *)
(* Cf. Part 6: § 6.8                               *)
fun asign(bitstring, skey): bitstring.
reduc forall m: bitstring, s: bitstring, k: skey;
       aread(asign(m, k)) = m.
reduc forall m: bitstring, s: bitstring, k: skey;
       acheck( asign(m, k), pk(k)) = true.
reduc forall m: bitstring, s: bitstring, k: skey;
       unwrap( asign(m, k), pk(k)) = m.
letfun verify(s: bitstring, m: bitstring, k: pkey) =
       (aread(s) = m && acheck(s, k)).

const void: bitstring. (* when the signature field is omitted *)

(* ECC Diffie - Hellman *)
type G.
type exponent.
fun bits_from_exp(exponent): bitstring [typeConverter].
fun bits_from_hk(G):         bitstring [typeConverter].
const no_hk: G.
const g: G [data].
fun exp(G, exponent): G.
(*{ if "ECC" in config["crypto"] }*)
equation forall x: exponent, y: exponent;
       exp( exp(g,x), y) = exp( exp(g,y), x).
(*{ endif }*)

(* Symmetric keys *)
type sekey. (* both encryption key and iv *)
type sskey. (* signing key                *)
const no_ek: sekey.
const no_mk: sskey.

(* Key derivation *)
type nonce.
const no_nonce: nonce. (* when the nonce field is omitted *)
fun bits_from_nonce(nonce): bitstring [typeConverter].
fun  enc_key_RSA(nonce, nonce): sekey.
fun sign_key_RSA(nonce, nonce): sskey.
fun  enc_key_ECC(G, G, G): sekey.
fun sign_key_ECC(G, G, G): sskey.
fun  enc_key_pwd_ECC(G, pkey, pkey): sekey.
fun sign_key_pwd_ECC(G, pkey, pkey): sskey.
fun nonce_from_hk(G):           nonce [typeConverter].
fun hk_from_nonce(nonce):           G [typeConverter].
fun hk_from_bits (bitstring):       G [typeConverter].

(* Symmetric encryption *)
fun senc(bitstring, sekey): bitstring.
reduc forall m: bitstring, k: sekey;
       sdec( senc(m, k), k) = m.

(* Symmetric "signature" (HMAC) *)
fun ssign(bitstring, sskey): bitstring.
reduc forall m: bitstring, k: sskey;
       sread(ssign(m, k)) = m.
reduc forall m: bitstring, k: sskey;
       scheck( ssign(m, k), k) = true.

(* Login, password and secret key *)
type login.
const anonymous: login.

type psswrd.
const no_pwd: psswrd.
fun pwd_of(login):psswrd [private].
fun encode(psswrd): bitstring [typeConverter].
fun sk_of(login): skey [private].

(* PKI *)
type certificate.
const null_cert: certificate.

type kind.
const client: kind.
const server: kind.
const user:   kind.

fun certify(kind, cryptography, pkey): certificate [private].
reduc forall k: kind, s: cryptography, pub: pkey;
       get_kind(certify(k, s, pub)) = k.
reduc forall k: kind, s: cryptography, pub: pkey;
       get_crypto_(certify(k, s, pub)) = s.
reduc forall k: kind, s: cryptography, pub: pkey;
       get_pk(certify(k, s, pub)) = pub.

letfun get_crypto(cert: certificate) =
   let crypto_ = get_crypto_(cert) in
   if allowed_crypto(crypto_) then crypto_.


(* Channels *)
type chid.
const NewCh: chid.

type chtoken.
const no_token: chtoken.

type chkeys.
const no_keys: chkeys.
fun keys(chtoken, sekey, sskey, sekey, sskey) : chkeys [data].
(* first client's keys, then server's keys *)
type channel_.
fun chan(certificate, certificate, chmode, chid, chkeys) : channel_ [data].

(* Modular OPN request/responses wrappers with data symbols, see below: (* Sign-enc helping function *)*)
type CH_header.  (* Determines whether OPN / MSG *)
type CH_payload. (* Determines whether request / response *)
fun CH(CH_header, CH_payload): bitstring                               [data]. (* Wrapper to store a channel request/response: same format for MSG/OPN *)
fun OPN_header(chid, cryptography, certificate, thumbprint): CH_header [data]. (* same for request/response *)
fun MSG_header(chid, chtoken): CH_header                               [data]. (* same for request/response *)
fun OPN_req (nonce, chmode, nonce): CH_payload                         [data]. (* requestId, Enc/Sign, Cnonce *)
fun OPN_resp(nonce, chid, chtoken, nonce): CH_payload                  [data]. (* requestId, channelId, tokenId, Snonce *)
fun MSG_req (nonce, bitstring): CH_payload                             [data]. (* requestId, request*)
fun MSG_resp(nonce, bitstring): CH_payload                             [data]. (* requestId, response *)
fun CH_req_c (bitstring): CH_payload                                   [data]. (* OPN/MSG request  with signed or/and encrypted payload *)
fun CH_resp_c(bitstring): CH_payload                                   [data]. (* OPN/MSG response with signed or/and encrypted payload *)

(*{ if authenticated }*)
(* Symmetric authenticated encryption *)
fun sa_enc_sign(CH_header, CH_payload, sekey): bitstring.
reduc forall m: CH_header, p: CH_payload, k: sekey;
       sa_dec( sa_enc_sign(m, p, k), k) = p.
reduc forall m: CH_header, p: CH_payload, k: sekey;
       sa_read( sa_enc_sign(m, p, k)) = m.
reduc forall m: CH_header, p: CH_payload, k: sekey;
      sa_check( sa_enc_sign(m, p, k), k) = true.
(*{ endif }*)

(* Sessions *)
type seid.
fun se_id(nonce): seid [typeConverter].
type stoken.  (* Session Authentication Token *)
type session.
fun  sess(pkey, pkey, channel_, chmode, smode, seid, stoken): session [data].

(* 4:§7.15 Ephemeral key type *)
type ephkey.
const no_fk: ephkey.
fun Ephemeral(bitstring): ephkey [data].

letfun get_hk(ek: ephkey, pk: pkey) =
   let Ephemeral(signed_hk: bitstring) = ek in
   if acheck(signed_hk, pk) then hk_from_bits(aread(signed_hk)).


(* session sub-protocol *)
fun SessionReq (bitstring): bitstring [data]. (* nonce, certificate, simplified to a bitstring (use pair instead) for signature oracle *)
fun SessionResp(ephkey, seid, stoken, nonce, certificate, bitstring): bitstring [data].

fun ActivateReq (stoken, bitstring, utoken, login, bitstring): bitstring [data].
fun ActivateResp(ephkey, nonce)                              : bitstring [data].

fun BasicReq (stoken, nonce): bitstring [data].
fun BasicResp(nonce)        : bitstring [data].

(* Tables *)
(* These tables record all the communication elements created by application instances. *)
table C_channels(certificate, certificate, chmode, chid, chkeys).
table S_channels(certificate, certificate, chmode, chid, chkeys).

table C_sessions(pkey, pkey, seid, stoken, smode, channel_, login, utoken, G, nonce, skey).
table S_sessions(pkey, pkey, seid, stoken, smode, channel_, login, utoken, exponent, nonce).
(* Because events and tables are handled differently during resolution, we introduce insert events triggered each time we insert an item *)

(* Authentication Service, accessible by servers and clients *)
table users(login, psswrd, skey, certificate).



(**************** Events **********************)
(**********************************************)

(* Events *)
event honest(pkey).                  (* The key was not given to the attacker  *)
event leaked(pkey).                  (* ... until it leaked.                   *)
event leaked_server(pkey).
event leak_ch(pkey, chkeys).
event new_user(login, psswrd, skey, pkey, certificate).
event used(psswrd, cryptography, chmode, smode).
event sec(pkey, pkey, bitstring).    (* secret shared by pk_1 to pk_2          *)
event secret_exp(exponent).
event secret_nonce(pkey, pkey, nonce, chmode).
event new_keys(pkey, pkey, cryptography, chkeys).
event C_data(pkey, pkey, cryptography, chmode, seid, nonce).
event S_data(pkey, pkey, cryptography, chmode, seid, nonce).
event C_Open(pkey, pkey, chmode, cryptography, bitstring).
event S_Open(pkey, pkey, chmode, cryptography, bitstring).
event C_Channel(channel_).
event S_Channel(channel_).
event C_Start_Session(channel_, chmode, smode).
event C_Session(session).
event S_Session(session).
event C_Activation_Req(pkey, pkey, chmode, smode, session, login, utoken)
(*{ if "3.1.E" in queries["list"] or "3.1" in queries["list"] }*)
[solveTwice] (*{ else }*) [solveOnce] (*{ endif }*)
.

event C_Activation(pkey, pkey, chmode, smode, session, login, utoken).
event S_Activation(pkey, pkey, chmode, smode, session, login, utoken).
event C_First_Activation(session, login).
event S_First_Activation(session, login, nonce).
event C_Reactivation(session, login, login).
event S_Reactivation(session, login, login).
event S_Switching(session, chid, chid).
event C_User_Request (pkey, pkey, chmode, session, login, pkey, nonce).
event S_User_Request (pkey, pkey, chmode, session, login, pkey, nonce).
event C_User_Response(pkey, pkey, chmode, session, login, pkey, nonce).
event S_User_Response(pkey, pkey, chmode, session, login, pkey, nonce).
event C_ECC_finished.
event S_ECC_finished.
event C_ECC_opened_secure_channel(chid).
event C_ECC_reopened_secure_channel(chid).
event S_ECC_opened_secure_channel(chid).
event S_ECC_reopened_secure_channel(chid).
event C_ECC_opened_unsecure_channel(chid).
event S_ECC_opened_unsecure_channel(chid).
event C_RSA_finished.
event S_RSA_finished.
event C_RSA_started_secure_channel.
event S_open_channel(chid, chmode, cryptography, bool). (* bool: true when reopen *)
event C_open_channel(chid, chmode, cryptography, bool). (* bool: true when reopen *)
event C_Created_Session(stoken, smode).
event S_Created_Session(stoken, smode).
event C_Activated_Session(stoken, utoken).
event C_Switched_Session(stoken, utoken).
event S_Activated_Session(stoken, utoken).
event C_Request(login, nonce, nonce).
event S_Request(login, nonce, nonce).
event C_Reached(bitstring).
event S_Reached(bitstring).
event Channel(pkey, pkey, cryptography, chmode, chid).
event Check_RqID(pkey, nonce, nonce).
event C_send_(pkey, pkey, chid, chmode, chkeys, bitstring).
event S_rcv_(pkey, pkey, chid, chmode, chkeys, bitstring).
event S_send_(pkey, pkey, chid, chmode, chkeys, bitstring).
event C_rcv_(pkey, pkey, chid, chmode, chkeys, bitstring).
event Oracle(pkey,bitstring).
event fresh_C_nonce(bitstring, nonce).
event insert_C_sessions(pkey, pkey, seid, stoken, smode, channel_, login, utoken, G, nonce, skey)
(*{ if "3.1.C" in queries["list"] }*)
[solveOnce]
(*{ elif "3.1.B" in queries["list"] }*)
[solveTwice]
(*{ endif }*).
event insert_S_sessions(pkey, pkey, seid, stoken, smode, channel_, login, utoken, exponent, nonce)
(*{ if "3.1.C" in queries["list"] }*)
[solveOnce]
(*{ elif "3.1.B" in queries["list"] }*)
[solveTwice]
(*{ endif }*).


(********** Protocol Processes ****************)
(**********************************************)

(* --- UA Secure Channel helping functions --- *)

(* Channel OPN / MSG helping function *)
(* replacePayload will: replace the payload field of CH_m with cipher, with the appropriate request/response payload wrapper *)
letfun replacePayload(CH_m: bitstring, cipher: bitstring) =
   let CH(header: CH_header, OPN_req (rqid: nonce, m: chmode, cn: nonce))              = CH_m in CH(header, CH_req_c (cipher)) else (
   let CH(header: CH_header, OPN_resp(rqid: nonce, id: chid, tok: chtoken, sn: nonce)) = CH_m in CH(header, CH_resp_c(cipher)) else (
   let CH(header: CH_header, MSG_req (rqid: nonce, request: bitstring))                = CH_m in CH(header, CH_req_c (cipher)) else (
   let CH(header: CH_header, MSG_resp(rqid: nonce, response: bitstring))               = CH_m in CH(header, CH_resp_c(cipher))
      ))).
(* Returns the payload of a MSG/OPN request/response *)
letfun get_payload(payload: CH_payload) =
   let CH_req_c (p: bitstring) = payload in p else (
   let CH_resp_c(p: bitstring) = payload in p ).

(* Asymmetric encryption with signature                    *)
(* None: header,                      body                 *)
(* ECC:  header,       asign((header, body), E_sk)         *)
(* RSA:  header, aenc( asign((header, body), E_sk), R_pk)  *)

letfun CH_sign_enc(CH_m: bitstring, mode: chmode, crypto: cryptography, E_sk: skey, R_pk: pkey) =
   let CH(head: CH_header, payload: CH_payload) = CH_m in
   if mode = None then (CH_m) (* returns in plaintext *)
   else let sigma = asign(CH_m, E_sk) in
   if crypto = ECC then (  (* in RSA, OPN payloads are always encrypted, even in mode=Sign. In ECC, payloads are never encrypted. *)
         replacePayload(CH_m, sigma)  (* returns CH_m whose plaintext is replaced by the signed message (plaintext can be retrieved with aread) *)
   ) else ( (* crypto = RSA *)
      let cipher = aenc(sigma, R_pk) in
         replacePayload(CH_m, cipher)
   ).

letfun CH_check_dec(CH_m: bitstring, mode: chmode, crypto: cryptography, R_sk: skey, E_pk: pkey) =
   let CH(head: CH_header, payload: CH_payload) = CH_m in
   if mode = None then (CH_m) (* no check and returns in plaintext *)
   else let load = get_payload(payload) in
   if crypto = ECC then (
     if acheck(load, E_pk) then
        let CH(=head, body: CH_payload) = aread(load) in
        aread(load) (* returns sign-checked message *)
   ) else ( (* crypto = RSA *)
     let plainPayload = adec(load, R_sk) in
     if acheck(plainPayload, E_pk) then
        let CH(=head, body: CH_payload) = aread(plainPayload) in
        aread(plainPayload) (* returns decrypted, and sign-checked message *)
   ).

(* Symmetric encryption with HMAC                              *)
(* None:    header,                      body                  *)
(* Sign:    header,        ssign((header, body), I_mk)         *)
(* Encrypt: header,   senc(ssign((header, body), I_mk), I_ek) :   unauthenticated encryption *)
(* Encrypt: header, sae_enc_sign((header, body), I_ek)        :   authenticated encryption *)

letfun CH_mac_enc(CH_m: bitstring, mode: chmode, ek: sekey, mk: sskey) =
   let CH(header: CH_header, payload: CH_payload) = CH_m in
   if mode = None then (CH_m) (* returns in plaintext *)
   else let sigma = ssign(CH_m, mk) in
   if mode = Sign then (
        replacePayload(CH_m, sigma)  (* returns CH_m whose plaintext is replaced by the ssigned message (plaintext can be retrieved with sread) *)
   ) else ( (* mode = Encrypt *)
      let cipher = (*{ if authenticated }*) sa_enc_sign(header, payload, ek) (*{ else }*) senc(sigma, ek) (*{ endif }*) in
      replacePayload(CH_m, cipher)
   ).

letfun CH_mac_dec(CH_m: bitstring, mode: chmode, ek: sekey, mk: sskey) =
   let CH(MSG_header(id: chid, tok: chtoken), payload: CH_payload) = CH_m in
   if mode = None then (CH_m) (* no check and returns in plaintext *)
   else let load = get_payload(payload) in
   if mode = Sign then (
      if scheck(load, mk) then
      let CH(MSG_header(=id, =tok), body: CH_payload) = sread(load) in
      sread(load) (* returns ssign-checked message *)
   ) else ( (* mode = Encrypt *)
      (*{ if not authenticated }*)
      let plainPayload = sdec(load, ek) in
      if scheck(plainPayload, mk) then
      let CH(MSG_header(=id, =tok), body: CH_payload) = sread(plainPayload) in
      sread(plainPayload) (* returns decrypted, and ssign-checked message *)
      (*{ else }*)
      if sa_check(load, ek) then
      let MSG_header(=id, =tok) = sa_read(load) in
      CH(sa_read(load), sa_dec(load, ek))
      (*{ endif }*)
   ).

(* For clients sending OPN requests *)
letfun OPN_req_send(C_cert,S_cert: certificate, C_sk: skey, mode: chmode, id: chid, RqID: nonce, nonce_or_hk: nonce) =
   let C_pk = get_pk(C_cert) in
   let S_pk = get_pk(S_cert) in
   let crypto = get_crypto(S_cert) in
   let thumb = if mode = None
      then no_print
      else (if crypto = RSA then h(S_pk) else (*{ if fixed }*) h(S_pk) (*{ else }*) no_print (*{ endif }*)) in
   let header = OPN_header(id, crypto, C_cert, thumb) in
   let nonce_or_hk_ = if mode = None then no_nonce else nonce_or_hk in
   let payload = OPN_req(RqID, mode, nonce_or_hk_) in
   let OPN_req_plain = CH(header, payload) in
   event C_Open(C_pk, S_pk, mode, crypto, bits_from_nonce(nonce_or_hk_));
   let OPN_request = CH_sign_enc(OPN_req_plain, mode, crypto, C_sk, S_pk) in
   OPN_request.


(*  For client/server sending a messages on a channel *)
letfun CH_send(isClient: bool, E_cert: certificate, R_cert: certificate, mode: chmode, id: chid, symkeys: chkeys, reqId: nonce, payload: bitstring) =
   let E_pk = get_pk(E_cert) in
   let R_pk = get_pk(R_cert) in
   let CHpayload = if isClient
      then MSG_req (reqId, payload)
      else MSG_resp(reqId, payload) in
   let (token: chtoken, C_enc_k: sekey, C_sign_k: sskey, S_enc_k: sekey, S_sign_k: sskey) =
      if mode = None then (no_token, no_ek, no_mk, no_ek, no_mk)
                     else (let keys(tk: chtoken, cek: sekey, cmk: sskey, sek: sekey, smk: sskey) = symkeys in
                          (tk, cek, cmk, sek, smk)) in
   let header = MSG_header(id, token) in
   let CH_m = CH(header, CHpayload) in
   let (C_pk: pkey, S_pk: pkey) = if isClient then (E_pk, R_pk) else (R_pk, E_pk) in
   let (ek: sekey, mk: sskey) = if isClient then (C_enc_k, C_sign_k) else (S_enc_k, S_sign_k) in
      CH_mac_enc(CH_m, mode, ek, mk).

(*  For client/server receiving a messages on a channel *)
letfun CH_rcv(isClient: bool, mode: chmode, id: chid, symkeys: chkeys, msg:bitstring) =
   let (token: chtoken, C_enc_k: sekey, C_sign_k: sskey, S_enc_k: sekey, S_sign_k: sskey) =
      if mode = None then (no_token, no_ek, no_mk, no_ek, no_mk)
                     else (let keys(tk: chtoken, cek: sekey, cmk: sskey, sek: sekey, smk: sskey) = symkeys in
                          (tk, cek, cmk, sek, smk)) in
   let CH(MSG_header(=id, =token), pay: CH_payload)  = msg in
   let (ek: sekey, mk: sskey) = if isClient then (S_enc_k, S_sign_k) else (C_enc_k, C_sign_k) in
   let rcv_checked = CH_mac_dec(msg, mode, ek, mk) in
   let CH(MSG_header(=id, =token), payload: CH_payload) = rcv_checked in
   if isClient
      then (let MSG_resp(reqId: nonce, response: bitstring) = payload in (reqId, response)) (* client expect to receive MSG_resp *)
      else (let MSG_req (reqId: nonce, request:  bitstring) = payload in (reqId, request )).(* client expect to receive MSG_req *)

(* Handling the special case of channel receive from servers *)
letfun S_rcv(S_cert: certificate, msg: bitstring) =
   let CH(MSG_header(id: chid, token: chtoken), pay: CH_payload) = msg in
   get S_channels(C_cert: certificate, =S_cert, mode: chmode, =id, symkeys: chkeys) suchthat allowed_channel(mode) in
   let crypto = get_crypto(S_cert) in
   let S_pk = get_pk(S_cert) in
   let C_pk = get_pk(C_cert) in
   if token = no_token && mode = None && symkeys = no_keys then (
      let (reqID: nonce, request: bitstring) = CH_rcv(false, None, id, no_keys, msg) in
      event S_rcv_(C_pk, S_pk, id, mode, no_keys, request);
      (C_cert, S_cert, None, id, no_keys, reqID, request)
  ) else (
     let keys(=token, x: sekey, y: sskey, x_: sekey, y_: sskey) = symkeys in
     let (reqID: nonce, request: bitstring) =  CH_rcv(false, mode, id, symkeys, msg) in
     event S_rcv_(C_pk, S_pk, id, mode, symkeys, request);
      (C_cert, S_cert, mode, id, symkeys, reqID, request)
  ).



(* --- Client --- *)


(* Create Session *)

let Create_Session (C_sk: skey, SC: channel_, check: smode) =
   let chan(C_cert: certificate, S_cert: certificate, mode: chmode, ch: chid, symkeys: chkeys) = SC in
   if get_pk(C_cert) = pk(C_sk) then
   let key_tk = (if mode = None then no_token else (
      let keys(key_tk: chtoken, w: sekey, x: sskey, y: sekey, z: sskey) = symkeys in (key_tk) )) in
   (* The OPCUA specifications (4:§5.6.2.1 and 7:§5.3 table 11) tolerate no application authentication
    * in two cases :
    * 1. if the channel is unsecure (but some server can still enforce application authentication)
    * 2. if the server explicitly desactivates application authentication.
    * If application authentication is checked then we need to
    *  - verify the application certificate given by the client.
    *  - verify the signature. *)
   (* We simplify here and demand application authentication if and only if check = SSec *) 
   new RqID[key_tk, check]: nonce; out(c, RqID); (* the request number is predictable *)
   let C_pk = get_pk(C_cert) in
   let S_pk = get_pk(S_cert) in
   event C_Start_Session(SC, mode, check);
   let crypto = get_crypto(S_cert) in

   (* Application Authentication checks *)
   new C_nonce[C_pk, ch]: nonce;
   let Req = (
      if check = SNone then SessionReq((no_nonce, null_cert))
                       else SessionReq((C_nonce, C_cert))) in
   out(c, CH_send(true, C_cert, S_cert, mode, ch, symkeys, RqID, Req));

   in(c, raw: bitstring);
   let (=RqID, response: bitstring) = CH_rcv(true, mode, ch, symkeys, raw) in
   let SessionResp(S_ek: ephkey, id: seid, token: stoken, S_nonce: nonce, S_app_cert: certificate, signature: bitstring) = response in
   if (check = SNone || S_app_cert = S_cert) then
   let S_hk = (
      if crypto = RSA then no_hk else
      if crypto = ECC then get_hk(S_ek, S_pk)
   ) in
   if (check = SNone || verify(signature, (C_cert, C_nonce), S_pk)) then
   out(c, id); (* the session number is public *)
   let C_sess = sess(C_pk, S_pk, SC, mode, check, id, token) in
   event C_Session(C_sess);
   event insert_C_sessions(C_pk, S_pk, id, token, check, SC, anonymous, user_none, S_hk, S_nonce, C_sk);
   insert C_sessions(C_pk, S_pk, id, token, check, SC, anonymous, user_none, S_hk, S_nonce, C_sk);
   event C_Created_Session(token, check).



(* Open or Reopen a Channel and then create a session *)

let Open_Channel_Create_Session (C_cert,S_cert: certificate, C_sk: skey, mode: chmode, id: chid, check: smode) =
   (* Simplification here: since there is no redirection to keys, keys used in sessions are not updated after a reopen *)
   (* we can create a new session for "old channels" that we reopen, by renewing the keys *)
   (* but we can't reopen a channel once a session is created, just to renew the keys *)
   let C_pk = get_pk(C_cert) in
   let S_pk = get_pk(S_cert) in
   new RqID    [C_pk, S_pk, mode, id] : nonce;  (* C_pk is NOT implicit *)
   out(c, RqID); (* Request Id is predictable *)
   (*{ if "3.1.axioms" in queries["list"] }*)
   new C_Nonce [S_pk, id, mode] : nonce;   (* RSA *)
   (*{ else }*)
   new C_Nonce [S_pk, id] : nonce;         (* RSA *)
   (*{ endif }*)
   new C_Secret[S_pk, id] : exponent;      (* ECC *)
   event secret_exp(C_Secret);
   let crypto = get_crypto(S_cert) in
   let is_reopen = id <> NewCh in

   (* Checking first opening or reopening allowed and existing old channel *)
   if not(is_reopen) || (reopening_allowed() && (mode <> None)) then   
   let _ = (if is_reopen then (get C_channels(=C_cert, =S_cert, =mode, =id, O_keys: chkeys) in ()) else ()) in

   (* Sending OPN request *)
   let C_nonce_or_hk: nonce = if crypto=RSA then C_Nonce else nonce_from_hk(exp(g, C_Secret)) in
   let OPNreq = OPN_req_send(C_cert, S_cert, C_sk, mode, id, RqID, C_nonce_or_hk) in
   out(c, OPNreq);


   (* Receiving and checking OPN response *)
   in(c, OPNresp: bitstring);
   let CH(OPN_header(ch_s: chid, =crypto, =S_cert, print: thumbprint), resp_payload: CH_payload) = CH_check_dec(OPNresp, mode, crypto, C_sk, S_pk) in
   let OPN_resp(=RqID, =ch_s, token: chtoken, S_nonce_or_hk: nonce) = resp_payload in
   if not(is_reopen) || ch_s = id then (* when reopening, the channel id in the response must be the same as the one in the request *)
   if (mode = None && print = no_print && token = no_token && S_nonce_or_hk = no_nonce)
      || (crypto = RSA && print = h(C_pk)) 
    (*{if fixed}*) 
      || (crypto = ECC && print = h(C_pk))  (* Fixed: thumbprint should be the hash of receiver's cert. *)
    (*{ else   }*)
      || (crypto = ECC && print = no_print) (* Not fixed: thumbprint should be empty in ECC *)
    (*{ endif  }*)
   then
   let sym_keys = if mode = None then no_keys else (
      if crypto = RSA then (
              let S_nonce = S_nonce_or_hk in
              let C_enc_k  =  enc_key_RSA(C_Nonce, S_nonce) in
              let C_sign_k = sign_key_RSA(C_Nonce, S_nonce) in
              let S_enc_k  =  enc_key_RSA(S_nonce, C_Nonce) in
              let S_sign_k = sign_key_RSA(S_nonce, C_Nonce) in
              keys(token, C_enc_k, C_sign_k, S_enc_k, S_sign_k)
      ) else ( (* crypto = ECC*)
           let C_halfkey = exp(g, C_Secret) in
           let S_halfkey = hk_from_nonce(S_nonce_or_hk) in
           if S_halfkey <> g then
           let C_sharedkey = exp(S_halfkey, C_Secret) in
              let C_enc_k  =  enc_key_ECC(C_halfkey, S_halfkey, C_sharedkey) in
              let C_sign_k = sign_key_ECC(C_halfkey, S_halfkey, C_sharedkey) in
              let S_enc_k  =  enc_key_ECC(S_halfkey, C_halfkey, C_sharedkey) in
              let S_sign_k = sign_key_ECC(S_halfkey, C_halfkey, C_sharedkey) in
              keys(token, C_enc_k, C_sign_k, S_enc_k, S_sign_k)
      )
   ) in

   (* Events *)
   event fresh_C_nonce(bits_from_nonce(C_nonce_or_hk), S_nonce_or_hk);
   event sec(C_pk, S_pk, bits_from_nonce(C_nonce_or_hk));
   event secret_nonce(C_pk, S_pk, C_Nonce, mode); (* Before it was only triggered in mode Sign | encrypt; added mode argument to allow conditioning *)
   event new_keys(C_pk, S_pk, crypto, sym_keys);  (* Queries using new_keys should be conditioned with `symkeys <> no_keys` *)
   event Channel(C_pk, S_pk, crypto, mode, ch_s);
   event C_Channel(chan(C_cert, S_cert, mode, ch_s, sym_keys));
   event C_open_channel(ch_s, mode, crypto, is_reopen);
   insert C_channels(C_cert, S_cert, mode, ch_s, sym_keys);
   ( !Create_Session(C_sk, chan(C_cert, S_cert, mode, ch_s, sym_keys), check)
(* Propagate reopened channels used by existing sessions *) 
   | if is_reopen then (
       !(get C_sessions(=C_pk,=S_pk, sessid: seid, SAtoken: stoken, check2: smode,
                     chan(=C_cert, =S_cert, =mode, =ch_s, O_keys: chkeys),
                     O_usr: login, O_tk: utoken, O_hk: G, O_nonce: nonce, =C_sk) in
         insert C_sessions(C_pk,S_pk, sessid, SAtoken, check2,
                     chan(C_cert, S_cert, mode, ch_s, sym_keys), (* key update *)
                     O_usr, O_tk, O_hk, O_nonce, C_sk)))
(* Channel leaks *)
   | (if allowed_leak(ch_leaks) then event leak_ch(C_pk, sym_keys); out(c, sym_keys))
   ).

(* Activate Session *)

let Activate_Session (usr: login, U_tk: utoken, U_pwd: psswrd, U_sk: skey, U_cert: certificate) =
   get C_sessions(C_pk,S_pk: pkey, id: seid, SAtoken: stoken, check: smode, SC: channel_,
                  O_usr: login, O_tk: utoken, O_hk: G, O_nonce: nonce, C_sk: skey)
   suchthat allowed_session(check) in
   let chan(C_cert,S_cert: certificate, mode: chmode, ch: chid, symkeys: chkeys) = SC in
   if C_pk = get_pk(C_cert) && S_pk = get_pk(S_cert) then
   new RqID[id, usr, U_tk] : nonce;
   out(c, RqID);
   let crypto = get_crypto(S_cert) in
   if allowed_crypto(crypto) then
   (* Client provides a signature only when check = SSec *)
   let signature = (if check = SSec then asign( (S_cert, O_nonce), C_sk) else void) in
   (* user "anonymous" is reserved to the user_anon authentication *)
   if (U_tk = user_anon && usr = anonymous) || (U_tk <> user_anon && usr <> anonymous) then
   let credential = (* password *)
       if U_tk <> user_pwd then void else
       if (mode = Encrypt) || (mode = None && check = SNone) then (O_nonce, U_pwd) else (
       if crypto = RSA then (
          new U_pek[C_pk]: sekey;
          new U_psk[C_pk]: sskey;
          (ssign( (aenc( (U_pek, U_psk), S_pk), O_nonce, senc(encode(U_pwd), U_pek)), U_psk))
       ) else
       if crypto = ECC then (
          new es_a[C_pk]: exponent;
          event secret_exp(es_a);
          let U_hk = exp(g, es_a) in
          let sh_k = exp(O_hk, es_a) in
          let U_pek =  enc_key_pwd_ECC(sh_k, C_pk, S_pk) in
          let U_psk = sign_key_pwd_ECC(sh_k, C_pk, S_pk) in
          (ssign( (U_hk, O_hk, O_nonce, senc(encode(U_pwd), U_pek)), U_psk)))
   ) in
   let ActivateRequest = (* Activate request. *)
      if U_tk = user_anon then ActivateReq(SAtoken, signature, user_anon, anonymous, void) else
      if U_tk = user_pwd  then event used(U_pwd, crypto, mode, check);
                               ActivateReq(SAtoken, signature, user_pwd,  usr, credential) else
      if U_tk = user_cert then ActivateReq(SAtoken, signature, user_cert, usr,
         (*{ if KCI }*) (U_cert, asign( (S_cert, O_nonce),       U_sk))
         (*{  else  }*) (U_cert, asign( (S_cert, O_nonce, C_pk), U_sk)) (*{endif}*)) in
   let C_sess = sess(C_pk, S_pk, chan(C_cert, S_cert, mode, ch, symkeys), mode, check, id, SAtoken) in
   event C_Activation_Req(C_pk, S_pk, mode, check, C_sess, usr, U_tk);
   out(c, CH_send(true, C_cert, S_cert, mode, ch, symkeys, RqID, ActivateRequest));

   in(c, raw: bitstring);
   let (=RqID, ActivateResp(S_ek: ephkey, S_nonce: nonce)) = CH_rcv(true, mode, ch, symkeys, raw) in
   let S_hk = ( (* half key used only in ECC *)
      if crypto = RSA then no_hk else
      if crypto = ECC then get_hk(S_ek, S_pk)
   ) in
   event C_Activated_Session(SAtoken, U_tk);
   event C_Activation(C_pk, S_pk, mode, check, C_sess, usr, U_tk);
   if O_tk = user_none then
      event C_First_Activation(C_sess, usr);
      event insert_C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, S_hk, S_nonce, C_sk);
      insert C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, S_hk, S_nonce, C_sk)
   else
      event C_Reactivation(C_sess, O_usr, usr);
      event insert_C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, S_hk, S_nonce, C_sk);
      insert C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, S_hk, S_nonce, C_sk)
   .

(* Switch Sessions from a channel to another *)

let Switch_Channel (usr: login, U_tk: utoken, U_pwd: psswrd, U_sk: skey, U_cert: certificate) =
   (* One can only switch the channel of an already activated and secured session *)
   if U_tk <> user_none then
   get C_sessions(C_pk,S_pk: pkey, id: seid, SAtoken: stoken, check: smode, O_SC: channel_,
                 =usr, =U_tk, O_hk: G, O_nonce: nonce, C_sk: skey) in
   if allowed_session(check) then
   let chan(C_cert,S_cert: certificate, mode: chmode, O_ch: chid, O_keys: chkeys) = O_SC in
   if C_pk = get_pk(C_cert) && S_pk = get_pk(S_cert) then
   new RqID[id, usr, U_tk]: nonce;   (* to prevent Proverif from looping *)
   out(c, RqID);
   (* An activation requests that changes the channel but not the user. *)
   get C_channels(=C_cert, =S_cert, =mode, ch: chid, symkeys: chkeys) suchthat ch <> O_ch in
   let SC = chan(C_cert, S_cert, mode, ch, symkeys) in
   let crypto = get_crypto(S_cert) in
   if allowed_crypto(crypto) then
   (* Client provides an application certificate and a signature only when check = SSec *)
   let signature = if check = SSec then asign( (S_cert, O_nonce), C_sk) else void in
   if (U_tk = user_anon && usr = anonymous) || (U_tk <> user_anon && usr <> anonymous) then
   let credential = (* password *)
      if U_tk <> user_pwd then void else
      if (mode = Encrypt) then (O_nonce, U_pwd) else (
      if crypto = RSA then (
         new U_pek[C_pk]: sekey;
         new U_pmk[C_pk]: sskey;
         (ssign( (aenc( (U_pek, U_pmk), S_pk), O_nonce, senc(encode(U_pwd), U_pek)), U_pmk))
      ) else
      if crypto = ECC then (
         new es_s[C_pk]: exponent;
         event secret_exp(es_s);
         let U_hk = exp(g, es_s) in
         let sh_k = exp(O_hk, es_s) in
         let U_pek =  enc_key_pwd_ECC(sh_k, C_pk, S_pk) in
         let U_psk = sign_key_pwd_ECC(sh_k, C_pk, S_pk) in
         (ssign( (U_hk, O_hk, O_nonce, senc(encode(U_pwd), U_pek)), U_psk)))
   ) in
   let ActivateRequest = (* Activate request.*)
      if U_tk = user_anon then ActivateReq(SAtoken, signature, user_anon, anonymous, void) else
      if U_tk = user_pwd  then event used(U_pwd, crypto, mode, check);
                               ActivateReq(SAtoken, signature, user_pwd,  usr, credential) else
      if U_tk = user_cert then ActivateReq(SAtoken, signature, user_cert, usr,
         (*{ if KCI }*) (U_cert, asign( (S_cert, O_nonce),       U_sk))
         (*{  else  }*) (U_cert, asign( (S_cert, O_nonce, C_pk), U_sk)) (*{endif}*)) in
   let C_sess = sess(C_pk, S_pk, chan(C_cert, S_cert, mode, ch, symkeys), mode, check, id, SAtoken) in
   event C_Activation_Req(C_pk, S_pk, mode, check, C_sess, usr, U_tk);
   out(c, CH_send(true, C_cert, S_cert, mode, ch, symkeys, RqID, ActivateRequest));

   in(c, raw: bitstring);
   let (=RqID, ActivateResp(S_ek: ephkey, S_nonce: nonce)) = CH_rcv(true, mode, ch, symkeys, raw) in
   let S_hk = ( (* half key used only in ECC *)
      if crypto = RSA then no_hk else
      if crypto = ECC then get_hk(S_ek, S_pk)
   ) in
   event C_Switched_Session(SAtoken, U_tk);
   event C_Activation(C_pk, S_pk, mode, check, C_sess, usr, U_tk);
   event insert_C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, S_hk, S_nonce, C_sk);
   insert C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, S_hk, S_nonce, C_sk).


(* Basic User Request *)

let User_Request (usr: login) = 
   get C_sessions(C_pk,S_pk: pkey, id: seid, SAtoken: stoken, check: smode, SC: channel_,
                  =usr, U_tk: utoken, O_hk: G, O_nonce: nonce, C_sk: skey)
   suchthat U_tk <> user_none in  (* Need to check this session was activated, because the anonymous user can make the request *)
   let chan(C_cert,S_cert: certificate, mode: chmode, ch: chid, symkeys: chkeys) = SC in
   if C_pk = get_pk(C_cert) && S_pk = get_pk(S_cert) then
   new RqID[S_pk, id, usr]: nonce; out(c, RqID);
   let C_sess = sess(C_pk, S_pk, SC, mode, check, id, SAtoken) in
   (* We let the attacker choose the value of the user request *)
   new C_val: nonce;
   let crypto = get_crypto(C_cert) in
   event C_data(C_pk, S_pk, crypto, mode, id, C_val);
   event C_User_Request(C_pk, S_pk, mode, C_sess, usr, pk(sk_of(usr)), C_val);
   out(c, CH_send(true, C_cert, S_cert, mode, ch, symkeys, RqID, BasicReq(SAtoken, C_val)));

   in (c, raw: bitstring);
   let (=RqID, BasicResp(S_val: nonce)) = CH_rcv(true, mode, ch, symkeys, raw) in
   event C_User_Response(C_pk, S_pk, mode, C_sess, usr, pk(sk_of(usr)), S_val);
   event C_Request(usr, C_val, S_val).




(* --- Server --- *)

letfun Notify_Activate_Reply(C_cert,S_cert: certificate, mode: chmode, O_ch,ch: chid, symkeys: chkeys,
                             check: smode, id: seid, SAtoken: stoken, O_usr,usr: login, O_tk,U_tk: utoken) =
   let C_pk = get_pk(C_cert) in
   let S_pk = get_pk(S_cert) in
   let sn = sess(C_pk, S_pk, chan(C_cert, S_cert, mode, ch, symkeys), mode, check, id, SAtoken) in
   if O_tk = user_none then (
        (* first activation *)
        new stamp[C_pk, S_pk]: nonce;
        event S_First_Activation(sn, usr, stamp)[];
        event S_Activation(C_pk, S_pk, mode, check, sn, usr, U_tk);()
   ) else if usr <> O_usr then (
        (* reactivation by a new user on the same channel *)
        if ch = O_ch then
        event S_Reactivation(sn, O_usr, usr)[C_pk, S_pk];
        event S_Activation(C_pk, S_pk, mode, check, sn, usr, U_tk)[];()
   ) else if ch <> O_ch then
        (* switching channel for the same user *)
        event S_Switching(sn, O_ch, ch)[C_pk, S_pk];
        event S_Activation(C_pk, S_pk, mode, check, sn, usr, U_tk)[];()
   else (* O_tk <> user_none && usr = O_usr && SC = O_SC :    *)
        (* the specifications allow a user to reauthenticate. *)
        event S_Activation(C_pk, S_pk, mode, check, sn, usr, U_tk)[];().


(* Server main process *)

let Server(S_sk: skey, S_cert: certificate, crypto: cryptography, mode: chmode, check: smode) =
   let S_pk = pk(S_sk) in

   (  (* OPN request and response *)
   (* Receive OPN request *)
   in(c, CHreq: bitstring)(*{ if queries["Sanity"] or ( ( not fixed ) and ("3.1" in queries["list"]) or ("3.1.0" in queries["list"]) or "3.2" in queries["list"] ) }*)[precise](*{ endif }*);
   let CH(OPN_header(ch: chid, =crypto, C_cert: certificate, print: thumbprint), payload: CH_payload) = CHreq in
   let is_reopen = ch <> NewCh in
   if not(is_reopen) || (reopening_allowed() && mode <> None) then
   if mode = None || (
    (*{if fixed}*) print = h(S_pk)
    (*{else}*) (crypto = RSA && print = h(S_pk)) || (crypto = ECC && print = no_print)
    (*{endif}*)) then
   if get_kind(C_cert) = client && get_crypto(C_cert) = crypto then
   let C_pk = get_pk(C_cert) in
   let CH(OPN_header(=ch, =crypto, =C_cert, =print), opn_req: CH_payload) = CH_check_dec(CHreq, mode, crypto, S_sk, C_pk) in
   let OPN_req(reqId: nonce, =mode, C_nonce_or_hk: nonce) = opn_req in

   (* Compute OPN response *)
   (*{if "3.1.axioms.XX1" in queries["list"] }*)  (* Could reintroduce the specialized nonce context for 3.1.axioms.1 here  *)
   new Token  [C_pk, S_pk, C_nonce_or_hk, ch]: chtoken;
   new S_Nonce[C_pk, S_pk, C_nonce_or_hk, ch]: nonce;
   (*{else}*)
   new Token  [C_pk, S_pk, C_nonce_or_hk]: chtoken;
   new S_Nonce[C_pk, S_pk]: nonce;
   (*{endif}*)
   (*{if "3.1.axioms.XX1" in queries["list"] }*)
   new S_secret[C_pk, S_pk, C_nonce_or_hk, ch]: exponent;
   (*{else}*)
   new S_secret[C_pk, S_pk]: exponent;
   (*{endif}*)
   event secret_nonce(S_pk, C_pk, S_Nonce, mode);
   event secret_exp(S_secret);
   let snonce_or_hk = if crypto = RSA then S_Nonce else nonce_from_hk(exp(g, S_secret)) in
   event sec(S_pk, C_pk, bits_from_nonce(snonce_or_hk));
   let sym_keys = if mode = None then no_keys
   else if crypto = RSA then (
        let C_nonce  = C_nonce_or_hk in
        let C_enc_k  =  enc_key_RSA(C_nonce, S_Nonce) in
        let C_sign_k = sign_key_RSA(C_nonce, S_Nonce) in
        let S_enc_k  =  enc_key_RSA(S_Nonce, C_nonce) in
        let S_sign_k = sign_key_RSA(S_Nonce, C_nonce) in
        keys(Token, C_enc_k, C_sign_k, S_enc_k, S_sign_k)
   ) else (
        let C_hk = hk_from_nonce(C_nonce_or_hk) in
        if C_hk <> g then
        let S_hk = exp(g, S_secret) in
        let S_sharedkey = exp(C_hk, S_secret) in
        let C_enc_k  =  enc_key_ECC(C_hk, S_hk, S_sharedkey) in
        let C_sign_k = sign_key_ECC(C_hk, S_hk, S_sharedkey) in
        let S_enc_k  =  enc_key_ECC(S_hk, C_hk, S_sharedkey) in
        let S_sign_k = sign_key_ECC(S_hk, C_hk, S_sharedkey) in
        keys(Token, C_enc_k, C_sign_k, S_enc_k, S_sign_k)
   ) in
   let SC_id = (if is_reopen then (get S_channels(=C_cert, =S_cert, =mode, =ch, O_keys: chkeys) in ch) else
   (*{ if "lemma" in queries["list"] }*) (new ch_n[C_pk, C_nonce_or_hk, S_pk, mode]: chid; ch_n)
   (*{ else }*)                          (new ch_n[C_pk, S_pk, mode]: chid; ch_n)
   (*{ endif }*)) in
   insert S_channels(C_cert, S_cert, mode, SC_id, sym_keys);
   event S_Channel(chan(C_cert, S_cert, mode, SC_id, sym_keys));
   event new_keys(C_pk, S_pk, crypto, sym_keys);
   event S_open_channel(SC_id, mode, crypto, is_reopen);
   event S_Open(C_pk, S_pk, mode, crypto, bits_from_nonce(C_nonce_or_hk));
   
   let hcert = if crypto = RSA then h(C_pk) else (*{if fixed}*) h(C_pk) (*{else}*) no_print (*{endif}*) in
   let (scert: certificate, dst_print: thumbprint, token: chtoken) =
      if mode = None then (null_cert, no_print, no_token) else (S_cert, hcert, Token) in
   let OPNresp = CH(OPN_header(SC_id, crypto, scert, dst_print), OPN_resp(reqId, SC_id, token, snonce_or_hk)) in
   ( out(c, CH_sign_enc(OPNresp, mode, crypto, S_sk, C_pk))
   | (if allowed_leak(ch_leaks) then event leak_ch(S_pk, sym_keys); out(c, sym_keys))
   |  if is_reopen then (
       !(get S_sessions(=C_pk,=S_pk, sessid: seid, SAtoken: stoken, check2: smode,
                     chan(=C_cert, =S_cert, =mode, =SC_id, O_keys: chkeys),
                     O_usr: login, O_tk: utoken, O_er: exponent, O_nonce: nonce) in
         insert S_sessions(C_pk,S_pk, sessid, SAtoken, check2,
                     chan(C_cert, S_cert, mode, SC_id, sym_keys), (* key update *)
                     O_usr, O_tk, O_er, O_nonce)))
   ) ) 

  |( (* B. Respond to requests for services *)
   new er[S_pk]: exponent;
   in(c, raw: bitstring);
   let (C_cert: certificate, =S_cert, =mode, ch: chid, symkeys: chkeys, RqID: nonce, req: bitstring) = S_rcv(S_cert, raw) in
   if get_kind(C_cert) = client then
   let SC = chan(C_cert, S_cert, mode, ch, symkeys) in
   let C_pk = get_pk(C_cert) in

   (* Create session *)
   let SessionReq(payload: bitstring) = req in (
    (* The OPCUA specifications (4:§5.6.2.1 and 7:§5.3 table 11) tolerate no application authentication
     * (check = SNone) in two cases :
     * 1. if the channel is unsecure (but some server can still enforce application authentication)
     * 2. if the server explicitly desactivates application authentication.
     * If application authentication is checked then we need:
     *  - to verify that the client application certificate is the same as the one used to open the channel.
     *  - to sign the nonce and client certificate with the server private key (of its application certificate. *)
      (* We need to limit the context of these fresh values to prevent Proverif from looping *)
      (* No Application Authentication in SNone or SNoAA ...*)
      (* ... and yet signing with S_sk when SNoAA*)
      let signature: bitstring =
                 (         if check = SNone then (void)
      (*{if oracle}*) else if check = SNoAA then (
                        (* mimic the fact that it is possible to stuff arbitrary data into a C_nonce, which is not properly parsed *)
                        let load: bitstring = (
                           let (C_nonce: nonce, C_app_cert: certificate) = payload in (C_app_cert, C_nonce)
                           else (event Oracle(pk(S_sk), payload); payload)) in
                        asign(load, S_sk))
      (*{ endif }*)   else
                        let (C_nonce: nonce, C_app_cert: certificate) = payload in
                        if (check = SNoAA || C_app_cert = C_cert) then
                        asign((C_app_cert, C_nonce), S_sk) ) in
   (*{if "3.1.axioms.1" in queries["list"] }*)
      new s[C_pk, S_pk, mode, check, payload]: nonce;
   (*{else}*)
      new s[C_pk, S_pk, mode, check]: nonce;
   (*{endif}*)
      let id = se_id(s) in
      new SAtoken[id]: stoken;  (* SAtoken[id, ch] (anonymous, user_none) *)
      let sn = sess(C_pk, S_pk, SC, mode, check, id, SAtoken) in
      out(c, id);                    (* Session ID is public *)
      (*{ if "3.1.axioms.XX1" in queries["list"] }*)
      new S_nonce[id, ch, SC, id]: nonce;
      (*{ else }*)
      new S_nonce[id, ch]: nonce;
      (*{ endif }*)
      event secret_exp(er);
      let S_hk = exp(g, er) in

      let S_ek =
         if crypto = RSA then no_fk else
         if crypto = ECC then Ephemeral(asign(bits_from_hk(S_hk), S_sk)) in
      let create_resp = SessionResp(S_ek, id, SAtoken, S_nonce, S_cert, signature) in (* S_cert and signature are sent even in SNone *)
      event S_Session(sn);
      event insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC, anonymous, user_none, er, S_nonce);
      insert S_sessions(C_pk, S_pk, id, SAtoken, check, SC, anonymous, user_none, er, S_nonce);
      event S_Created_Session(SAtoken, check);
      out(c, CH_send(false, S_cert, C_cert, mode, ch, symkeys, RqID, create_resp))
   ) else

   (* Activate session *)
   let ActivateReq(SAtoken: stoken, signature: bitstring, U_tk: utoken, usr: login, credential: bitstring) = req in (
      if allowed_crypto(crypto) && allowed_token(U_tk) then (
      get S_sessions(=C_pk, =S_pk, id: seid, =SAtoken, =check, O_SC: channel_,
                     O_usr: login, O_tk: utoken, O_er: exponent, O_nonce: nonce)
      in
      (* Application Authentication <=> SSec *)
      if (check = SNone || check= SNoAA) || verify( signature, (S_cert, O_nonce), C_pk) then
      let chan(=C_cert, =S_cert, =mode, O_ch: chid, O_keys: chkeys) = O_SC in
      (* first activation on the same channel, reactivation on a different channel only for the same user *)
      if ( (O_SC = SC ) (* no switch *)
       || ((ch <> O_ch) && (O_tk <> user_none) && (U_tk = O_tk) && (usr = O_usr) && switching_allowed())) then (* switch *)
      (*{ if "3.1.axioms" in queries["list"] }*)
      new S_nonce[id, ch, usr, U_tk, SC, SAtoken]: nonce;  (* information required to find the previous activation *)
      (*{ else }*)
         (*{ if "3.1.axioms.XX1" in queries["list"] }*)
         new S_nonce[id, ch, usr, U_tk, SC, id, SAtoken]: nonce;  (* information required to find the previous activation *)
         (*{ else }*)
         new S_nonce[id, ch, usr, U_tk]: nonce;  (* information required to find the previous activation *)
      (*{ endif }*)
      (*{ endif }*)
      event secret_exp(O_er);
      event secret_exp(er);
      let S_hk = exp(g, er) in
      let S_sess = sess(C_pk, S_pk, SC, mode, check, id, SAtoken) in
      let S_ek = (
         if crypto = RSA then no_fk else
         if crypto = ECC then Ephemeral(asign(bits_from_hk(S_hk), S_sk)) ) in
      (* Anonymous *)
      if U_tk = user_anon && usr = anonymous then (
         event S_Activated_Session(SAtoken, user_anon);
         event insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, er, S_nonce);
         insert S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, er, S_nonce);
         let _ = Notify_Activate_Reply(C_cert, S_cert, mode, O_ch,ch, symkeys,
                                       check, id, SAtoken, O_usr,usr, O_tk,U_tk) in
         out(c, CH_send(false, S_cert, C_cert, mode, ch, symkeys, RqID, ActivateResp(S_ek, S_nonce)))
      ) else
      if usr <> anonymous then
      get users(=usr, U_pwd: psswrd, U_sk: skey, U_cert: certificate) in
      (* Password *)
      if U_tk = user_pwd && (
         (* by default we allow unencrypted user credential if the channel is encrypted *)
         if (mode = Encrypt) || (mode = None && check = SNone)
         then credential = (O_nonce, U_pwd)
         else if crypto = RSA then (
            let (U_keys: bitstring, =O_nonce, enc_pwd: bitstring) = sread(credential) in
            let (U_pek: sekey, U_pmk: sskey) = adec(U_keys, S_sk) in
               (scheck(credential, U_pmk) && sdec(enc_pwd, U_pek) = encode(U_pwd)))
         else if crypto = ECC then (
            let O_hk = exp(g, O_er) in
            let (U_hk: G, =O_hk, =O_nonce, enc_pwd: bitstring) = sread(credential) in
            let sh_k  = exp(U_hk, O_er) in
            let U_pek =  enc_key_pwd_ECC( sh_k, C_pk, S_pk) in
            let U_psk = sign_key_pwd_ECC( sh_k, C_pk, S_pk) in
               (scheck(credential, U_psk) && sdec(enc_pwd, U_pek) = encode(U_pwd)))
      ) then (
         event S_Activated_Session(SAtoken, user_pwd);
         let x = Notify_Activate_Reply(C_cert, S_cert, mode, O_ch,ch, symkeys,
                                check, id, SAtoken, O_usr,usr, O_tk,U_tk) in
         event insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, er, S_nonce);      
         insert S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, er, S_nonce);
         out(c, CH_send(false, S_cert, C_cert, mode, ch, symkeys, RqID, ActivateResp(S_ek, S_nonce)))
      ) else
      (* Certificate *)
      if U_tk = user_cert then (
         let (=U_cert, U_sign: bitstring) = credential in if
         (*{ if KCI }*) verify( U_sign, (S_cert, O_nonce),       pk(U_sk))
         (*{  else  }*) verify( U_sign, (S_cert, O_nonce, C_pk), pk(U_sk)) (*{ endif}*)
         then event S_Activated_Session(SAtoken, user_cert);
         let x = Notify_Activate_Reply(C_cert, S_cert, mode, O_ch,ch, symkeys,
                                check, id, SAtoken, O_usr,usr, O_tk,U_tk) in
         event insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, er, S_nonce);
         insert S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, er, S_nonce);
         out(c, CH_send(false, S_cert, C_cert, mode, ch, symkeys, RqID, ActivateResp(S_ek, S_nonce)))
      )
   )) else

   (* Basic User Request *)
   let BasicReq(SAtoken: stoken, C_val: nonce) = req in (
      new stamp[]: nonce;
      event Check_RqID(S_pk, RqID, stamp);
      get S_sessions(=C_pk, =S_pk, id: seid, =SAtoken, =check, =SC, usr: login, U_tk: utoken, S_er: exponent, S_nonce: nonce)
      suchthat U_tk <> user_none in
      event secret_exp(S_er);
      let S_sess = sess(C_pk, S_pk, SC, mode, check, id, SAtoken) in
      event S_User_Request(C_pk, S_pk, mode, S_sess, usr, pk(sk_of(usr)), C_val);
      (* We let the attacker choose the value of the user request *)
      new S_val: nonce;
      event S_Request(usr, C_val, S_val);
      event S_data(C_pk, S_pk, crypto, mode, id, S_val);
      event S_User_Response(C_pk, S_pk, mode, S_sess, usr, pk(sk_of(usr)), S_val);
      out(c, CH_send(false, S_cert, C_cert, mode, ch, symkeys, RqID, BasicResp(S_val)))
   )
 ).


(* Restriction to express freshness of request ID *)
restriction src: pkey, rqid: nonce, i,j: nonce;
   event(Check_RqID(src, rqid, i)) && event(Check_RqID(src, rqid, j)) ==> i = j.


(********** Security Properties ***************)
(**********************************************)

(* -- Sanity checks -- *)
(* Sanity checks: all must be FALSE *)
(*{ if queries["Sanity"] }*)
const test : bitstring.

query id: chid, t: stoken, n: nonce, m: nonce, usr: login, b: bitstring, pk:pkey;
      event(S_open_channel(id, None,    RSA, false));
      event(S_open_channel(id, Sign,    RSA, false));
      event(S_open_channel(id, Encrypt, RSA, false));
      event(S_open_channel(id, None,    ECC, false));
      event(S_open_channel(id, Sign,    ECC, false));
      event(S_open_channel(id, Encrypt, ECC, false));
      event(C_open_channel(id, None,    RSA, false));
      event(C_open_channel(id, Sign,    RSA, false));
      event(C_open_channel(id, Encrypt, RSA, false));
      event(C_open_channel(id, None,    ECC, false));
      event(C_open_channel(id, Sign,    ECC, false));
      event(C_open_channel(id, Encrypt, ECC, false));
      (* reopen : *)
      event(S_open_channel(id, None,    RSA, true));
      event(S_open_channel(id, Sign,    RSA, true));
      event(S_open_channel(id, Encrypt, RSA, true));
      event(S_open_channel(id, None,    ECC, true));
      event(S_open_channel(id, Sign,    ECC, true));
      event(S_open_channel(id, Encrypt, ECC, true));
      event(C_open_channel(id, None,    RSA, true));
      event(C_open_channel(id, Sign,    RSA, true));
      event(C_open_channel(id, Encrypt, RSA, true));
      event(C_open_channel(id, None,    ECC, true));
      event(C_open_channel(id, Sign,    ECC, true));
      event(C_open_channel(id, Encrypt, ECC, true));

      event(S_Created_Session(t, SNone));
      event(S_Created_Session(t, SNoAA));
      event(S_Created_Session(t, SSec));
      event(C_Created_Session(t, SNone));
      event(C_Created_Session(t, SNoAA));
      event(C_Created_Session(t, SSec));
      event(S_Activated_Session(t, user_anon));
      event(S_Activated_Session(t, user_pwd));
      event(S_Activated_Session(t, user_cert));
      event(C_Activated_Session(t, user_anon));
      event(C_Activated_Session(t, user_pwd));
      event(C_Activated_Session(t, user_cert));
      event(C_Switched_Session(t, user_anon));
      event(C_Switched_Session(t, user_pwd));
      event(C_Switched_Session(t, user_cert));
      event(S_Request(usr, n, m));
      event(C_Request(usr, n, m));
      event(S_Reached(b));
      event(C_Reached(b));
      event(Oracle(pk, test)).

 (*{ endif }*)



(* ------- Confidentiality ------- *)

(*{ if queries["Confidentiality"] }*)

(* Conf[C]: Confidentiality of data sent by clients. *)
(*{ if "Conf[C]" in queries["list"] }*)
query SecPo: cryptography, mode: chmode, SE: seid, R: nonce, ch: chid, ck: chkeys,
      C_pk,S_pk: pkey, t,ts: time;
(*{ if queries["Unconditioned"] }*)
   event(C_data(C_pk, S_pk, SecPo, mode, SE, R)) &&
      attacker(R) ==> event(leaked(S_pk));
(*{ endif }*)
   event(C_data(C_pk, S_pk, SecPo, Encrypt, SE, R))@t &&
      attacker(R) ==> event(leaked(S_pk))@ts && (SecPo = RSA || ts < t).
(*{ endif }*)

(* Conf[S]: Confidentiality of data received by clients. *)
(*{ if "Conf[S]" in queries["list"] }*)
query SecPo: cryptography, mode: chmode, SE: seid, R: nonce, ch: chid, ck: chkeys,
      C_pk,S_pk: pkey, t,tc: time;
(*{ if queries["Unconditioned"] }*)
   event(S_data(C_pk, S_pk, SecPo, mode, SE, R)) &&
      attacker(R) ==> event(leaked(C_pk));
(*{ endif }*)
   event(S_data(C_pk, S_pk, SecPo, Encrypt, SE, R))@t &&
      attacker(R) ==>   event(leaked(C_pk))@tc && (SecPo = RSA || tc < t).
(*{ endif }*)


(* Conf[Pwd]: Confidentiality of user password, without PFS.  *)
(* According to Part. 4 §7.41.4 table 193, False if:
 *  - (mode = None    && check = SNone), lines 1 & 2: no encryption.
 *  - (mode = Encrypt && event(leak_ch(...)) ), line 7: no encryption but encrypted secure channel *)
(*{ if "Conf[Pwd]" in queries["list"] }*)
query U: login, pwd: psswrd, U_sk: skey, C_pk,S_pk,U_pk: pkey, U_cert: certificate, crypto: cryptography,
      mode: chmode, ch: chid, ck: chkeys, check: smode, sn: seid, tk: stoken;
   let SC = chan(certify(client, crypto, C_pk), certify(server, crypto, S_pk), mode, ch, ck) in
   let SE = sess(C_pk, S_pk, SC, mode, check, sn, tk) in
   event(new_user(U, pwd, U_sk, U_pk, U_cert)) && attacker(pwd)
      ==>  event(leaked(U_pk))
       ||  event(C_Activation_Req(C_pk, S_pk, mode, check, SE, U, user_pwd)) && event(leaked(S_pk)).
(*{ endif }*)

(*{ endif }*)



(* ------- Authentication/Integrity: Agreement properties ------- *)

(*{ if queries["Authentication"] }*)

(*** Agr[S->C] The server authenticates the user and the session on the client machine of a request (3.1) *)

(* 3.1.race: This query finds the user race condition attack (Attack Section 5.2) (with or without --not-fixed) *)
(*{ if "3.1.0" in queries["list"] or "Agr[S->C]" in queries["list"] }*)
query C_pk,S_pk,C'_pk,S'_pk: pkey, C_cert,S_cert,C'_cert,S'_cert: certificate, mode,mode': chmode, ch,ch': chid, ck,ck': chkeys,
      check,check': smode, id,id': seid, SAtk,SAtk': stoken, U: login, U_pk: pkey, R: nonce;
   let SC = chan(C_cert, S_cert, mode, ch, ck) in
   let SE = sess(C_pk, S_pk, SC, mode, check, id, SAtk) in
   let SC' = chan(C'_cert, S'_cert, mode', ch', ck') in
   let SE' = sess(C'_pk, S'_pk, SC', mode', check', id', SAtk') in
   inj-event(S_User_Request(C_pk, S_pk, mode, SE, U, U_pk, R)) && event(honest(C_pk)) && event(honest(U_pk)) (* The honest events are not strictly needed since certificates associated to C_pk and S_pk are necessarily checked against the PKI, hence they must have been honestly generated. Importantly, this does not prevent those clients and servers to be compromised! Indeed, the associated private keys can leak! *)
   ==> inj-event(C_User_Request(C_pk, S_pk, mode, SE, U, U_pk, R))
    || event(leaked(C_pk)) &&
       (   U = anonymous
        || event(leaked(U_pk))
        ||(event(C_Activation_Req(C'_pk, S'_pk, mode', check', SE', U, user_pwd)) && event(leaked(S'_pk)) )
       ).
(*{ endif }*)

(*   Because of potential race conditions due to a lack of commitment from the client on the new user
 *   handling a session after a re-activation, the server cannot be sure that the received message
 *   originates from the **latest** user handling the session.
 *   Therefore, we must accept the following residual risk, that can be seen as a weakness of the protocol:
 *   the request comes either from the current user, or a previous user of the same session that the
 *   server has already seen. *)

(*{ if "3.1" in queries["list"] }*)
query rogue_server,src3,dst3,clt,clt3,srv,srv3: pkey, c_cert,c_cert3,s_cert,s_cert3: certificate, mode,mode2,mode3: chmode, ch1,ch2,ch3: chid,
      ck1,ck2,ck3: chkeys, check,check2,check3: smode, id,id3: seid, SAtk,SAtk3: stoken, usr1,usr2: login, U_tk: utoken,
      upk1,upk2: pkey, val: nonce, sn3: session,utk:utoken;
(*{ if queries["Unconditioned"] }*)
(* 3.1.KCI: to find KCI attack (with or without --not-fixed) *)
   let SC1 = chan(c_cert, s_cert, mode, ch1, ck1) in
   let sn1 = sess(clt, srv, SC1, mode, check, id, SAtk) in
   let SC2 = chan(c_cert, s_cert, mode, ch2, ck2) in
   let sn2 = sess(clt, srv, SC2, mode, check, id, SAtk) in

     event(S_User_Request(clt, srv, mode, sn1, usr1, upk1, val)) && event(honest(clt)) && event(honest(upk1))
     ==> (     event(C_User_Request(clt, srv, mode, sn1, usr2, upk2, val))
            && event(S_Activation(clt, srv, mode, check, sn2, usr2, U_tk)) )
        || (event(leaked(clt)) || mode = None) &&
          (   usr1 = anonymous
           || event(leaked(upk1))
           || ( event(C_Activation_Req(clt3, srv3, mode3, check3, sn3, usr1, user_pwd)) && event(leaked(srv3)) )
          );
(*{ endif }*)

(* 3.1.ECC: to find the ECC impersonation attack (Attack Section 5.3) with --not-fixed *)
(* Also: Agr-[S->C]: weakened agreement property Agr-[S->C] (without --not-fixed) *)
   let SC1 = chan(c_cert, s_cert, mode, ch1, ck1) in
   let sn1 = sess(clt, srv, SC1, mode, check, id, SAtk) in
   let SC2 = chan(c_cert, s_cert, mode, ch2, ck2) in
   let sn2 = sess(clt, srv, SC2, mode, check, id, SAtk) in
     inj-event(S_User_Request(clt, srv, mode, sn1, usr1, upk1, val)) && event(honest(clt)) && event(honest(upk1))
     ==> ( inj-event(C_User_Request(clt, srv, mode, sn1, usr2, upk2, val))
            && event(S_Activation(clt, srv, mode, check, sn2, usr2, U_tk))
         )
        || (* Or the client AND the user were compromised/not secure *)
               (* Client compromission/not secure *)
          (event(leaked(clt)) || mode = None) 
            && ((* User compromission/not secure *)
                 usr1 = anonymous
              || event(leaked(pk(sk_of(usr1))))
              || event(leaked_server(rogue_server)) (* possibly bind rogue_server in a different C_Activation(usr) event *)
              || event(C_Activation_Req(src3, dst3, mode3, check3, sn3, usr1, utk)) && (mode3 = None || mode3 = Sign) (* can provide any S_nonce and user will sign *)
              )
        || event(leaked(srv)). (* to eliminate KCI attack (residual risk) *)
(*{ endif }*)




(*** Agr[C->S] The client authenticates the user context and the session of a response from the server (3.2) *)

(*{ if "3.2.0" in queries["list"] or "Agr[C->S]" in queries["list"] }*)
query C_pk,S_pk: pkey, C_cert,S_cert: certificate, mode: chmode, ch: chid, ck: chkeys,
      check: smode, id: seid, SAtk: stoken, U: login, utk: utoken, U_pk: pkey, R: nonce;
   let SC = chan(C_cert, S_cert, mode, ch, ck) in
   let SE = sess(C_pk, S_pk, SC, mode, check, id, SAtk) in
   inj-event(C_User_Response(C_pk, S_pk, mode, SE, U, U_pk, R))
   ==> inj-event(S_User_Response(C_pk, S_pk, mode, SE, U, U_pk, R))
    || event(leaked_server(S_pk)).
(*{ endif }*)

(*{ if "3.2" in queries["list"] }*)
query clt,srv: pkey, c_cert,s_cert: certificate, mode: chmode, ch1, ch2: chid, ck1,ck2: chkeys, check: smode,
      id: seid, tk: stoken, usr1,usr2: login, upk1,upk2: pkey, utk: utoken, val: nonce;
(*   Same as for Agr[S->C]: the wanted property is falsified due to residual risks.
 *   Indeed, there is a lack of commitment from the client on the new user handling a session after a re-activation,
 *   the server accepts directly the new user, without knowing if the client did receive its message informing
 *   that the reactivation succeeded. Normally, the client should wait for the server reply, and that reply should
 *   arrive thanks to the TCP connexion and the channel integrity and finally the client should switch to the new
 *   user context.
 *
 *   But, there is a potential race condition here if the client sends a request before receiving the answer to
 *   it's new user activation. In that case, when the reply arrives, it can't say if it was in the context of
 *   the old user or in the context of the new user. *)
(*{ if queries["Unconditioned"] }*)
   let SC = chan(c_cert, s_cert, mode, ch1, ck1) in
   let sn = sess(clt, srv, SC, mode, check, id, tk) in
   event(C_User_Response(clt, srv, mode, sn, usr1, upk1, val))
   ==> event(S_User_Response(clt, srv, mode, sn, usr1, upk1, val)) || event(leaked(srv));
(*{ endif }*)

(* Also: Agr-[C->S]: weakened agreement property Agr-[S->C] (without --not-fixed) *)
(*   Therefore, we must accept the following possibility, that can be seen as a weakness of the protocol:
 *   the response comes either in the context of the previous user or in the context of the new user on the
 *   same client. *)
   let SC1 = chan(c_cert, s_cert, mode, ch1, ck1) in
   let sn1 = sess(clt, srv, SC1, mode, check, id, tk) in
   let SC2 = chan(c_cert, s_cert, mode, ch2, ck2) in
   let sn2 = sess(clt, srv, SC2, mode, check, id, tk) in
   inj-event(C_User_Response(clt, srv, mode, sn1, usr1, upk1, val))
     ==> (inj-event(S_User_Response(clt, srv, mode, sn1, usr2, upk2, val))
           && event(S_Activation(clt, srv, mode, check, sn2, usr2, utk)) )
      || event(leaked(srv))
      || (mode = None).
(*{ endif }*)


(*{ endif }*)




(*************** Proof Helpers ****************)
(**********************************************)

(* -- NoSelect/Not attacker -- *)

(*** Not attacker *)
(* exponents for DH in ECC *)
(*{ if not "3.1.C" in queries["list"] }*)
not attacker(new C_Secret).
not attacker(new S_secret).
not attacker(new er).
not attacker(new es_a).
(*{ if config["switch"] }*)
not attacker(new es_s).
(*{ endif }*)
(*{ endif }*)


(*** No Select *)
(*{ if fixed and
   ("3.1" in queries["list"] or "3.1.A" in queries["list"] or "3.1.B" in queries["list"] or "3.1.C" in queries["list"] or "3.1.D" in queries["list"] or "3.1.E" in queries["list"] or "3.2" in queries["list"]) }*)

(* Required to prove the lemmas in ECC (no need for RSA) *)
noselect bg: G, x: exponent; attacker(exp( *bg, *x)).
noselect sh_k: G, C_pk,S_pk: pkey; attacker( enc_key_pwd_ECC( *sh_k, *C_pk, *S_pk)).
noselect sh_k: G, C_pk,S_pk: pkey; attacker(sign_key_pwd_ECC( *sh_k, *C_pk, *S_pk)).

noselect x: kind, y: cryptography, pk: pkey; attacker(certify( *x, *y, *pk)).
(*{ if not "3.1.E" in queries["list"] }*)
noselect n: nonce, c: certificate, k: skey; attacker(asign(( *n, *c ), *k )).
(*{ endif }*)
noselect usr: login; attacker(pwd_of( *usr )).
(*{ if not "3.1.D" in queries["list"] }*)
noselect usr: login; attacker(sk_of( *usr )).
(*{ endif }*)

noselect x1,x2: certificate, x3: chmode, x4: chid, x5: chkeys; table(S_channels( *x1,*x2,*x3,*x4,*x5))/8000
(*{ if "3.1" in queries["list"] }*) [ignoreAFewTimes] (*{ endif }*).

noselect x1,x2: certificate, x3: chmode, x4: chid, x5: chkeys; table(C_channels( *x1,*x2,*x3,*x4,*x5))/8000
(*{ if "3.1" in queries["list"] }*) [ignoreAFewTimes] (*{ endif }*).

noselect x1,x2:pkey, x3:seid, x4:stoken, x5:smode, x6:channel_, x7:login, x8:utoken, x9:exponent, x10:nonce;
table(S_sessions( *x1,*x2,*x3,*x4,*x5,*x6,*x7,*x8,*x9,*x10))/9000
(*{ if "3.1.C" in queries["list"] or "3.2" in queries["list"]}*) [ignoreAFewTimes] (*{ endif }*).


noselect x1,x2:pkey, x3:seid, x4:stoken, x5:smode, x6:channel_, x7:login, x8:utoken, x9:G, x10:nonce, x11:skey;
table(C_sessions( *x1,*x2,*x3,*x4,*x5,*x6,*x7,*x8,*x9,*x10,*x11))/9000
(*{ if "3.1.C" in queries["list"] }*) [ignoreAFewTimes] (*{ endif }*).
(*{ endif }*)


(* -- Lemmas -- *)

(** Lemmas for Agr[S->C] (3.1) *)
(* BELOW are the 5 lemmas we can prove with all no select and basic lemmas. They are enough to then prove the query Agr[S->C]/3.1 *)

(* [LEMMA A] Proved with all noSelect *)
(* Property: insertions in table S_session follow an activation, except at session creation where user token is user_none. NEEDS [solveOnce]*)
(*{ if fixed and ("3.1.A" in queries["list"] or "3.1" in queries["list"] or "3.2" in queries["list"]) }*)
(*{ if "3.1.A" in queries["list"] }*) query (*{ else }*) axiom (*{ endif }*)
C_pk,S_pk: pkey, id: seid, SAtoken: stoken, mode: chmode, check: smode, c_cert,s_cert: certificate, ch: chid, ck:chkeys,
usr: login, utk: utoken, er: exponent, S_nonce: nonce;
   let SC  = chan(c_cert, s_cert, mode, ch, ck) in
   event(insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, utk, er, S_nonce))
   ==> event(S_Activation(C_pk, S_pk, mode, check, sess(C_pk, S_pk, SC, mode, check, id, SAtoken), usr, utk))
   || utk = user_none
    [induction].
(*{ endif }*)


(* [LEMMA B] Proved with all noselect, and the lemma C) *)
(* Property: a session at a client must match one at a server or a leak occurred. *)
(* /!\ When used as an axiom to prove 3.1 we need [solveOnce] option on insert_X_sessions events *)
(*{ if fixed and ("3.1.B" in queries["list"] or "3.1" in queries["list"] or "3.2" in queries["list"]) }*)
(*{ if "3.1.B" in queries["list"] }*) query (*{ else }*) axiom (*{ endif }*)
C_pk,S_pk,C_pk2,S_pk2: pkey, id,id2: seid, check: smode, usr,usr2: login, U_tk,U_tk2: utoken, er,er2: exponent, ger: G, S_nonce,S_nonce2: nonce, C_sk:skey,
      SAtoken,SAtoken2: stoken, c_cert,s_cert,c_cert2,s_cert2: certificate, mode: chmode, ch: chid, ck: chkeys;

   let SC  = chan(c_cert,  s_cert,  mode, ch, ck) in
   let SC2 = chan(c_cert2, s_cert2, mode, ch, ck) in

           table(C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, ger, S_nonce, C_sk))
==> event(insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk,  er, S_nonce))
    || event(leaked_server(S_pk))
    || mode = None
    [induction].
(*{ endif }*)


(* [LEMMA C] needed for the proof of lemma B. Those relate the new insert_events to tables.
 * Property: insertions in tables are always done with an insert event. True by construction.
 * They can be proved using noslect on the corresponding table with the [ignoreAFewTimes] flag.*)
(*{ if fixed and ("3.1.E" in queries["list"] or "3.1.C" in queries["list"] or "3.1.B" in queries["list"] or "3.1" in queries["list"] or "3.2" in queries["list"]) }*)
(*{ if "3.1.C" in queries["list"] }*)
noselect x:bitstring; attacker( *x ). query
(*{ else }*) axiom (*{ endif }*)
C_pk,S_pk: pkey, id: seid, SAtoken: stoken, check: smode, SC: channel_, usr: login, U_tk: utoken, er: exponent, ger:G, S_nonce: nonce, C_sk: skey;
          table(S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk,  er, S_nonce))
==>event(insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk,  er, S_nonce));
          table(C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, ger, S_nonce, C_sk))
==>event(insert_C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, ger, S_nonce, C_sk)).
(*{ endif }*)

(* [LEMMA D] only for RSA. *)
(*{ if fixed and ("3.1.D" in queries["list"] or "3.1" in queries["list"] or "3.2" in queries["list"]) }*)
(*{ if "3.1.D" in queries["list"] }*)
query (*{ else }*) axiom (*{ endif }*) src,dst: pkey, n: nonce, mode: chmode;
   event(honest(src)) && event(honest(dst)) &&
   event(secret_nonce(src, dst, n, mode)) && mode <> None && attacker(n) ==> event(leaked(dst)).
(*{ endif }*)


(*{ if fixed and ("3.1.E" in queries["list"] or "3.1" in queries["list"]) }*)
(*{ if not "3.1.E" in queries["list"] }*) axiom (*{ else }*) query (*{ endif }*)
      chtk1,chtk2: chtoken, 
      C_enc_k1,C_enc_k2,S_enc_k1,S_enc_k2: sekey, C_sign_k1, C_sign_k2, C_sign_k,S_sign_k, S_sign_k1,S_sign_k2: sskey,
      c_cert1,c_cert2,s_cert1,s_cert2: certificate, mode1,mode2: chmode, ch1,ch2: chid,
      upk1,C_pk1,C_pk2,S_pk1,S_pk2,srv: pkey, id1,id2: seid, SAtoken, SAtoken1, SAtoken2: stoken, check1,check2: smode, usr1,usr2: login, U_tk1,U_tk2: utoken,
      er,er2: exponent, ger,ger2: G, S_nonce,S_nonce1,S_nonce2,S_nonce3: nonce, C_sk1,C_sk2:skey, SC: channel_,sn,sn2:session,val:nonce, ki:kind, crypto:cryptography, stamp:nonce,
      src2,dst2,src,dst,rogue_server: pkey, mode: chmode, check: smode, usr: login, utk: utoken
      ;

   event(S_Activation(src, dst, mode, check, sn, usr, utk))
       ==>  event(C_Activation_Req(src, dst, mode, check, sn, usr, utk))
         ||  (* Pair client/user were compromised or not secured *)
            (* Client compromission/not secure *)
            (event(leaked(src)) || mode = None) 
            && ((* User compromission/not secure *)
                 usr = anonymous
              || event(leaked(pk(sk_of(usr))))
              || event(leaked_server(rogue_server)) (* possibly bind rogue_server in a different C_Activation(usr) event *)
              || event(C_Activation_Req(src2, dst2, mode2, check2, sn2, usr, utk)) && (mode2 = None || mode2 = Sign) (* can provide any S_nonce and user will sign *)
              )
 [induction].
(*{ endif }*)


(** Lemmas for Agr[C->S] (3.2) *)
(* [Lemma A] *)
(*{ if "3.2.A" in queries["list"] or "3.2" in queries["list"] }*)
(*{ if "3.2.A" in queries["list"] }*) query (*{ else }*) axiom (*{ endif }*)
      chtk1,chtk2: chtoken,
      C_enc_k1,C_enc_k2,S_enc_k1,S_enc_k2: sekey, C_sign_k1, C_sign_k2, C_sign_k,S_sign_k, S_sign_k1,S_sign_k2: sskey,
      c_cert1,c_cert2,s_cert1,s_cert2: certificate, mode1,mode2: chmode, ch1,ch2: chid,
      C_pk1,C_pk2,S_pk1,S_pk2: pkey, id1,id2: seid, SAtoken, SAtoken1, SAtoken2: stoken, check1,check2: smode, usr1,usr2: login, U_tk1,U_tk2: utoken,
      er,er2: exponent, ger,ger2: G, S_nonce,S_nonce1,S_nonce2,S_nonce3: nonce, C_sk1,C_sk2:skey;

(* Matching client's symmetric signature key between two client sessions => matching channels *)
    let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k1) in
    let SK2 = keys(chtk2, C_enc_k2, C_sign_k1, S_enc_k2, S_sign_k2) in
    let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
    let SC2 = chan(c_cert2, s_cert2, mode2, ch2, SK2) in

    event(insert_C_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1, ger,  S_nonce1, C_sk1))
 && event(insert_C_sessions(C_pk2, S_pk2, id2, SAtoken2, check2, SC2, usr2, U_tk2, ger2, S_nonce2, C_sk2))
==> C_enc_k1 = C_enc_k2 && S_enc_k1 = S_enc_k2 && S_sign_k1 = S_sign_k2 
    (* && chtk1 = chtk2 
    && ch1 = ch2 *) (* previous two lines not required to prove 3.2 *)
    && C_pk1 = C_pk2 && S_pk1 = S_pk2
.
(*{ endif }*)


(******* BASIC LEMMA *************)
(* BELOW ARE THE LEMMAS that can all be proved without any noselect. Just turns axioms into queries. *)

(*{ if "3.1.axioms.1" in queries["list"] }*)
(* This restriction expresses the freshness of C_nonce with respect to S_nonce *)
restriction C_n1:bitstring, S_n1,S_n2:nonce;
   event(fresh_C_nonce(C_n1,S_n1))
&& event(fresh_C_nonce(C_n1,S_n2))
 ==> S_n1 = S_n2.
(*{ endif }*)


(*{ if fixed and
   ("3.1.axioms.1" in queries["list"] or "3.1" in queries["list"] or "3.1.A" in queries["list"] or "3.1.B" in queries["list"] or "3.1.C" in queries["list"] or "3.1.D" in queries["list"] or "3.1.E" in queries["list"] or "3.2" in queries["list"]) }*)
(* Matching client's symmetric signature key + SAtoken => matching channel+session *)

(*{ if not "3.1.axioms.1" in queries["list"] }*) axiom (*{ else }*) query (*{ endif }*)
      chtk1,chtk2: chtoken, 
      C_enc_k1,C_enc_k2,S_enc_k1,S_enc_k2: sekey, C_sign_k1, C_sign_k2, C_sign_k,S_sign_k, S_sign_k1,S_sign_k2: sskey,
      c_cert1,c_cert2,s_cert1,s_cert2: certificate, mode1,mode2: chmode, ch1,ch2: chid,
      rogue_server,upk1,C_pk1,C_pk2,S_pk1,S_pk2,srv: pkey, id1,id2: seid, SAtoken, SAtoken1, SAtoken2: stoken, check1,check2: smode, usr1,usr2: login, U_tk1,U_tk2: utoken,
      exp,er,er2: exponent, ger,ger2: G, S_nonce,S_nonce1,S_nonce2,S_nonce3: nonce, C_sk1,C_sk2:skey, SC: channel_,sn:session,val:nonce, ki:kind, crypto,crypto1,crypto2,crypto3,crypto4:cryptography, stamp:nonce,SK1_, SK2_:chkeys;

    let SK1 = keys(chtk1, C_enc_k1, C_sign_k, S_enc_k1, S_sign_k1) in
    let SK2 = keys(chtk2, C_enc_k2, C_sign_k, S_enc_k2, S_sign_k2) in
    let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
    let SC2 = chan(c_cert2, s_cert2, mode2, ch2, SK2) in
 
    event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken, check1, SC1, usr1, U_tk1,  er, S_nonce1))
 && event(insert_C_sessions(C_pk2, S_pk2, id2, SAtoken, check2, SC2, usr2, U_tk2, ger, S_nonce2, C_sk2))
 ==> C_pk1 = C_pk2  && S_pk1 = S_pk2 
   && (check1 = check2 )
   && SC1 = SC2
   && (id1 = id2 ) 
   ||    event(leaked(C_pk1))
      && event(leaked_server(srv))
   .
(*{ endif }*)


(*{ if fixed and
   ("3.1.axioms" in queries["list"] or "3.1" in queries["list"] or "3.1.A" in queries["list"] or "3.1.B" in queries["list"] or "3.1.C" in queries["list"] or "3.1.D" in queries["list"] or "3.1.E" in queries["list"] or "3.2" in queries["list"]) }*)

(*{ if not "3.1.axioms" in queries["list"] }*) axiom (*{ else }*) query (*{ endif }*)
srv:pkey; event(leaked_server(srv)) ==> event(leaked(srv)).

(*{ if not "3.1.axioms" in queries["list"] }*) axiom (*{ else }*) query (*{ endif }*)
      chtk1,chtk2: chtoken, 
      C_enc_k1,C_enc_k2,S_enc_k1,S_enc_k2: sekey, C_sign_k1, C_sign_k2, C_sign_k,S_sign_k, S_sign_k1,S_sign_k2: sskey,
      c_cert1,c_cert2,s_cert1,s_cert2: certificate, mode1,mode2: chmode, ch1,ch2: chid,
      rogue_server,upk1,C_pk1,C_pk2,S_pk1,S_pk2,srv: pkey, id1,id2: seid, SAtoken, SAtoken1, SAtoken2: stoken, check1,check2: smode, usr1,usr2: login, U_tk1,U_tk2: utoken,
      exp,er,er2: exponent, ger,ger2: G, S_nonce,S_nonce1,S_nonce2,S_nonce3: nonce, C_sk1,C_sk2:skey, SC: channel_,sn:session,val:nonce, ki:kind, crypto,crypto1,crypto2,crypto3,crypto4:cryptography, stamp:nonce,SK1_, SK2_:chkeys;

    let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1_) in
    let SC2 = chan(c_cert2, s_cert2, mode2, ch2, SK2_) in
 
    event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1,  er, S_nonce1))
 && event(insert_C_sessions(C_pk2, S_pk2, id2, SAtoken2, check2, SC2, usr2, U_tk2, ger, S_nonce1, C_sk2))
 ==> C_pk1 = C_pk2  && S_pk1 = S_pk2
 && SC1 = SC2
 && id1 = id2 && check1 = check2
 &&  SAtoken1 = SAtoken2
   || event(leaked_server(rogue_server))
   || usr1 = anonymous
   ;



   (* Matching keys in channels ==> same channel *)
    let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k1) in
    let SK2 = keys(chtk2, C_enc_k2, C_sign_k2, S_enc_k2, S_sign_k1) in
   table(S_channels(certify(client,crypto1,C_pk1), s_cert1, mode1, ch1, SK1))
&& table(C_channels(c_cert2, certify(server,crypto2,S_pk2), mode2, ch2, SK2))
==> certify(client,crypto1,C_pk1) = c_cert2 && certify(server,crypto2,S_pk2) = s_cert1
    && mode1 = mode2 && ch1 = ch2 && SK1 = SK2        
|| event(leaked(C_pk1)) || event(leaked_server(S_pk2));

    let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k1) in
    let SK2 = keys(chtk2, C_enc_k2, C_sign_k2, S_enc_k1, S_sign_k2) in
   table(S_channels(certify(client,crypto1,C_pk1), s_cert1, mode1, ch1, SK1))
&& table(C_channels(c_cert2, certify(server,crypto2,S_pk2), mode2, ch2, SK2))
==> certify(client,crypto1,C_pk1) = c_cert2 && certify(server,crypto2,S_pk2) = s_cert1
    && mode1 = mode2 && ch1 = ch2 && SK1 = SK2        
|| event(leaked(C_pk1)) || event(leaked_server(S_pk2));

    let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k1) in
    let SK2 = keys(chtk2, C_enc_k2, C_sign_k1, S_enc_k2, S_sign_k2) in
   table(S_channels(certify(client,crypto1,C_pk1), s_cert1, mode1, ch1, SK1))
&& table(C_channels(c_cert2, certify(server,crypto2,S_pk2), mode2, ch2, SK2))
==> certify(client,crypto1,C_pk1) = c_cert2 && certify(server,crypto2,S_pk2) = s_cert1
    && mode1 = mode2 && ch1 = ch2 && SK1 = SK2        
|| event(leaked(C_pk1)) || event(leaked_server(S_pk2));

    let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k1) in
    let SK2 = keys(chtk2, C_enc_k1, C_sign_k2, S_enc_k2, S_sign_k2) in
   table(S_channels(certify(client,crypto1,C_pk1), s_cert1, mode1, ch1, SK1))
&& table(C_channels(c_cert2, certify(server,crypto2,S_pk2), mode2, ch2, SK2))
==> certify(client,crypto1,C_pk1) = c_cert2 && certify(server,crypto2,S_pk2) = s_cert1
    && mode1 = mode2 && ch1 = ch2 && SK1 = SK2        
|| event(leaked(C_pk1)) || event(leaked_server(S_pk2));


    let SK1 = keys(chtk1, C_enc_k1, C_sign_k, S_enc_k1, S_sign_k1) in
    let SK2 = keys(chtk2, C_enc_k2, C_sign_k, S_enc_k2, S_sign_k2) in
    let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
    let SC2 = chan(c_cert2, s_cert2, mode2, ch2, SK2) in

    event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1,  er, S_nonce1))
 && event(insert_C_sessions(C_pk2, S_pk2, id2, SAtoken2, check2, SC2, usr2, U_tk2, ger, S_nonce2, C_sk2))
==> (C_pk1 = C_pk2 && S_pk1 = S_pk2 && c_cert1=c_cert2 && s_cert1=s_cert2 && mode1=mode2
       && ch1=ch2  && SK1 = SK2)
     ||  event(leaked(C_pk1)) &&
               (
                  ( event(leaked_server(srv)) )
               );

   (* With noselect, ProVerif assume the contrary! *)
   attacker(sk_of(usr1)) && event(honest(pk(sk_of(usr1)))) ==> event(leaked(pk(sk_of(usr1))));

   attacker(pwd_of(usr1)) ==>
   event(leaked(pk(sk_of(usr1))))
   || event(leaked_server(rogue_server));

(* No user key in client/server  *)
    event(insert_S_sessions(pk(sk_of(usr1)), S_pk1, id1, SAtoken1, check1, SC, usr1, U_tk1,  er, S_nonce1))
   ==> false;
    event(insert_S_sessions(C_pk1, pk(sk_of(usr1)), id1, SAtoken1, check1, SC, usr1, U_tk1,  er, S_nonce1))
   ==> false;
    event(insert_C_sessions(pk(sk_of(usr1)), S_pk2, id2, SAtoken2, check2, SC, usr2, U_tk2, ger, S_nonce2, C_sk2))
   ==> false;
    event(insert_C_sessions(C_pk1, pk(sk_of(usr1)), id2, SAtoken2, check2, SC, usr2, U_tk2, ger, S_nonce2, C_sk2))
   ==> false;


(* Matching server's symmetric signature key => matching channel *)
    let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k) in
    let SK2 = keys(chtk2, C_enc_k2, C_sign_k2, S_enc_k2, S_sign_k) in
    let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
    let SC2 = chan(c_cert2, s_cert2, mode2, ch2, SK2) in

    event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1,  er, S_nonce1))
 && event(insert_C_sessions(C_pk2, S_pk2, id2, SAtoken2, check2, SC2, usr2, U_tk2, ger, S_nonce2, C_sk2))
==> (C_pk1 = C_pk2 && S_pk1 = S_pk2 && c_cert1=c_cert2 && s_cert1=s_cert2 (*&& mode1=mode2
       && ch1=ch2 *) && SK1 = SK2)
     ||  event(leaked(C_pk1));


(* Matching server's symmetric signature key and session ID => matching SAtoken *)
    let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k) in
    let SK2 = keys(chtk2, C_enc_k2, C_sign_k2, S_enc_k2, S_sign_k) in
    let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
    let SC2 = chan(c_cert2, s_cert2, mode2, ch2, SK2) in

    event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1,  er, S_nonce1))
 && event(insert_C_sessions(C_pk1, S_pk1, id1, SAtoken2, check1, SC1, usr1, U_tk1, ger, S_nonce1, C_sk2))
==> (SAtoken1 = SAtoken2)
    ||  event(leaked_server(S_pk1));


(* necessary for proof in SNone mode *)
(* true even with dishonest client/server *)
    let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k) in
    let SK2 = keys(chtk1, C_enc_k2, C_sign_k2, S_enc_k2, S_sign_k) in
    let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
    let SC2 = chan(c_cert2, s_cert2, mode2, ch2, SK2) in

    event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1,  er, S_nonce1))
 && event(insert_C_sessions(C_pk2, S_pk2, id2, SAtoken2, check2, SC2, usr2, U_tk2, ger, S_nonce2, C_sk2))
==> ( SK1 = SK2 );

    let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k) in
    let SK2 = keys(chtk1, C_enc_k2, C_sign_k2, S_enc_k2, S_sign_k) in
    let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
    let SC2 = chan(c_cert2, s_cert2, mode2, ch2, SK2) in

    event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1,  er, S_nonce))
 && event(insert_C_sessions(C_pk2, S_pk2, id2, SAtoken2, check2, SC2, usr2, U_tk2, ger, S_nonce, C_sk2))

==> ( C_pk1 = C_pk2 && S_pk1 = S_pk2 && id1 = id2 && SAtoken1 = SAtoken2 && SC1 = SC2 )
   || ((event(leaked(C_pk1)) ||  event(leaked_server(S_pk1))) && 
      (event(leaked(C_pk2)) || event(leaked_server(S_pk2))));

let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k) in
let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
let SC2 = chan(c_cert2, s_cert1, mode1, ch1, SK1) in

   event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1, er,  S_nonce1))
&& event(insert_C_sessions(C_pk2, S_pk1, id2, SAtoken2, check2, SC2, usr1, U_tk1, ger, S_nonce1, C_sk2))
==> C_pk1 = C_pk2 && id1=id2 && check1=check2 || event(leaked_server(S_pk1));


let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k) in
let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
let SC2 = chan(c_cert2, s_cert2, mode1, ch2, SK1) in

   event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1, er,  S_nonce1))
&& event(insert_C_sessions(C_pk2, S_pk2, id1, SAtoken1, check1, SC2, usr1, U_tk1, ger, S_nonce1, C_sk2))
==> C_pk1 = C_pk2 && S_pk1 = S_pk2 
      || event(leaked_server(S_pk2));

(* same channel keys *)
let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k) in
let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
let SC2 = chan(c_cert2, s_cert2, mode2, ch1, SK1) in

   event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1, er,  S_nonce1))
&& event(insert_C_sessions(C_pk2, S_pk2, id2, SAtoken2, check2, SC2, usr1, U_tk1, ger, S_nonce1, C_sk2))
==> mode1=mode2 
      || event(leaked_server(S_pk2));



    let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k) in
    let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
    let SC2 = chan(c_cert2, s_cert2, mode1, ch1, SK1) in

    event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1,  er, S_nonce1))
 && event(insert_C_sessions(C_pk2, S_pk2, id2, SAtoken2, check2, SC2, usr1, U_tk2, ger, S_nonce1, C_sk2))
==> ( SC1 = SC2 && C_pk1 = C_pk2 && S_pk1 = S_pk2 && id1 = id2 && SAtoken1 = SAtoken2 && check1 = check2 && U_tk1 = U_tk2)
  || event(leaked_server(S_pk2));

(* Matching server's symmetric signature key between two server sessions => matching channels *)
    let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k1) in
    let SK2 = keys(chtk2, C_enc_k2, C_sign_k2, S_enc_k2, S_sign_k1) in
    let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
    let SC2 = chan(c_cert2, s_cert2, mode2, ch2, SK2) in

    event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1, er, S_nonce1))
 && event(insert_S_sessions(C_pk2, S_pk2, id2, SAtoken2, check2, SC2, usr2, U_tk2, er2, S_nonce2))
==> C_enc_k1 = C_enc_k2 && C_sign_k1 = C_sign_k2 && S_enc_k1 = S_enc_k2.



(* [LEMMA 2] can be proved in seconds without any noselect. *)
(* Property: clients of S_sessions have private secret keys or were leaked. *)
(*{ if "3.1.axioms" in queries["list"] }*) query (*{ else }*) axiom (*{ endif }*)
      C_sk_2,C_sk,S_sk: skey, S_pk,S_pk2,C_pk, C_pk2: pkey, id: seid, check: smode, usr: login, U_tk: utoken, er: exponent, S_nonce, C_Nonce, S_nonce2: nonce, SAtoken: stoken, SC_: channel_,
      ger: G, chtk:chtoken, C_enc_k,S_enc_k: sekey, C_sign_k, S_sign_k: sskey, c_cert1,s_cert1,c_cert,s_cert: certificate, ch: chid, mode,mode1: chmode, C_halfkey,S_halfkey:G, C_sharedkey:G, crypto:cryptography, SK_:chkeys;

   (* Public keys are of the right form: pk(secret key) *)
    event(insert_C_sessions(C_pk, S_pk, id, SAtoken, check, SC_, usr, U_tk, ger, S_nonce, C_sk))
      ==> S_pk = pk(S_sk) && C_pk = pk(C_sk);
    event(insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC_, usr, U_tk, er, S_nonce))
      ==> S_pk = pk(S_sk) && C_pk = pk(C_sk);

   (* Certs are of the right form *)
    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    let SC = chan(c_cert, s_cert, mode, ch, SK) in
    event(insert_C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, ger, S_nonce, C_sk))
    ==> c_cert = certify(client, crypto, C_pk2) && s_cert = certify(server, crypto, S_pk2);

    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    let SC = chan(c_cert, s_cert, mode, ch, SK) in
    event(insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC_, usr, U_tk, er, S_nonce))
    ==> c_cert = certify(client, crypto, C_pk2) && s_cert = certify(server, crypto, S_pk2);

    event(insert_C_sessions(C_pk, S_pk, id, SAtoken, check, SC_, usr, user_anon, ger, S_nonce, C_sk))
      ==> usr = anonymous;

    event(insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC_, usr, user_anon, er, S_nonce))
      ==> usr = anonymous;

(* Public keys in client/server tables are pk(secret) or leaked *)
    event(insert_C_sessions(pk(C_sk), S_pk, id, SAtoken, check, SC_, usr, U_tk, ger, S_nonce, C_sk)) && attacker(C_sk)
      ==> event(leaked(pk(C_sk)));

    event(insert_C_sessions(C_pk, pk(S_sk), id, SAtoken, check, SC_, usr, U_tk, ger, S_nonce, C_sk)) && attacker(S_sk)
      ==> event(leaked_server(pk(S_sk)));

    event(insert_S_sessions(C_pk, pk(S_sk), id, SAtoken, check, SC_, usr, U_tk, er, S_nonce)) && attacker(S_sk)
      ==> event(leaked_server(pk(S_sk)));

    event(insert_S_sessions(pk(C_sk), S_pk, id, SAtoken, check, SC_, usr, U_tk, er, S_nonce)) && attacker(C_sk)
      ==> event(leaked(pk(C_sk)));

   (* [Channels] Symmetric signature keys are secret or private keys are leaked *)
    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    table(S_channels(c_cert1, s_cert1, mode1, ch, SK)) && attacker(S_sign_k)
      ==> c_cert1 = certify(client, crypto, C_pk) && event(leaked(C_pk));

    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    table(S_channels(c_cert1, s_cert1, mode1, ch, SK)) && attacker(C_sign_k)
      ==> c_cert1 = certify(client, crypto, C_pk) && event(leaked(C_pk));

    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    table(S_channels(c_cert1, s_cert1, mode1, ch, SK)) && attacker(C_enc_k)
      ==> c_cert1 = certify(client, crypto, C_pk) && event(leaked(C_pk));

    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    table(S_channels(c_cert1, s_cert1, mode1, ch, SK)) && attacker(S_enc_k)
      ==> c_cert1 = certify(client, crypto, C_pk) && event(leaked(C_pk));
      
    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    table(C_channels(c_cert1, s_cert1, mode1, ch, SK)) && attacker(S_sign_k)
      ==> s_cert1 = certify(server, crypto, S_pk) && event(leaked(S_pk));

    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    table(C_channels(c_cert1, s_cert1, mode1, ch, SK)) && attacker(C_sign_k)
      ==> s_cert1 = certify(server, crypto, S_pk) && event(leaked(S_pk));

    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    table(C_channels(c_cert1, s_cert1, mode1, ch, SK)) && attacker(C_enc_k)
      ==> s_cert1 = certify(server, crypto, S_pk) && event(leaked(S_pk));

    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    table(C_channels(c_cert1, s_cert1, mode1, ch, SK)) && attacker(S_enc_k)
      ==> s_cert1 = certify(server, crypto, S_pk) && event(leaked(S_pk));

   (* [Sessions] Symmetric signature keys are secret or private keys are leaked *)
    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    let SC = chan(c_cert, s_cert, mode, ch, SK) in
    event(insert_C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, ger, S_nonce, C_sk)) && attacker(S_sign_k)
      ==> S_pk = pk(S_sk) && event(leaked_server(pk(S_sk)));

    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    let SC = chan(c_cert, s_cert, mode, ch, SK) in
    event(insert_C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, ger, S_nonce, C_sk)) && attacker(C_sign_k)
      ==> S_pk = pk(S_sk) && event(leaked_server(pk(S_sk)));

    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    let SC = chan(c_cert, s_cert, mode, ch, SK) in
    event(insert_C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, ger, S_nonce, C_sk)) && attacker(C_enc_k)
      ==> S_pk = pk(S_sk) && event(leaked_server(pk(S_sk)));

    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    let SC = chan(c_cert, s_cert, mode, ch, SK) in
    event(insert_C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, ger, S_nonce, C_sk)) && attacker(S_enc_k)
      ==> S_pk = pk(S_sk) && event(leaked_server(pk(S_sk)));

    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    let SC = chan(c_cert, s_cert, mode, ch, SK) in
    event(insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, er, S_nonce)) && attacker(S_sign_k)
      ==> C_pk = pk(C_sk) && event(leaked(pk(C_sk)));

    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    let SC = chan(c_cert, s_cert, mode, ch, SK) in
    event(insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, er, S_nonce)) && attacker(C_sign_k)
      ==> event(leaked(C_pk));

    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    let SC = chan(c_cert, s_cert, mode, ch, SK) in
    event(insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, er, S_nonce)) && attacker(C_enc_k)
      ==> C_pk = pk(C_sk) && event(leaked(pk(C_sk)));

    let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k, S_sign_k) in
    let SC = chan(c_cert, s_cert, mode, ch, SK) in
    event(insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, er, S_nonce)) && attacker(S_enc_k)
      ==> event(leaked(C_pk));

(* Lemma for ECC: Sufficient to avoid the cannot be proved for 3.1/3.1.A due to noselect exp( *g, *x) *)
    let C_enc_k_  =  enc_key_ECC(C_halfkey, S_halfkey, C_sharedkey) in
    let SK = keys(chtk, C_enc_k_, C_sign_k, S_enc_k, S_sign_k) in
    let SC = chan(c_cert, s_cert, mode, ch, SK) in
    event(insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, er, S_nonce)) && attacker(C_sharedkey)
      ==> C_pk = pk(C_sk) && event(leaked(pk(C_sk)));
  
   let S_enc_k_  =  enc_key_ECC(C_halfkey, S_halfkey, C_sharedkey) in
   let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k_, S_sign_k) in
   let SC = chan(c_cert, s_cert, mode, ch, SK) in
    event(insert_C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, ger, S_nonce, C_sk)) && attacker(C_sharedkey)
      ==> S_pk = pk(S_sk) && event(leaked_server(pk(S_sk)));


(* Lemma for RSA: *)
    let C_enc_k_  =  enc_key_RSA(C_Nonce, S_nonce) in
    let SK = keys(chtk, C_enc_k_, C_sign_k, S_enc_k, S_sign_k) in
    let SC = chan(c_cert, s_cert, mode, ch, SK) in
    event(insert_S_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, er, S_nonce2)) && attacker(S_nonce)
      ==> C_pk = pk(C_sk) && event(leaked(pk(C_sk)));
  
   let S_enc_k_  =  enc_key_RSA(S_nonce, C_Nonce) in
   let SK = keys(chtk, C_enc_k, C_sign_k, S_enc_k_, S_sign_k) in
   let SC = chan(c_cert, s_cert, mode, ch, SK) in
    event(insert_C_sessions(C_pk, S_pk, id, SAtoken, check, SC, usr, U_tk, ger, S_nonce2, C_sk)) && attacker(C_Nonce)
      ==> S_pk = pk(S_sk) && event(leaked_server(pk(S_sk))).
(************************ END OF LEMMAS **********************************)
(*{ endif }*) (*  3.1.axioms  *)

(***  Lemmas for Agr[C->S] (3.2) *)
(* BELOW ARE THE LEMMAS that can all be proved without any noselect. Just turns axioms into queries. *)

(* 3.2.axioms. Avoid them to prove 3.2.A, otherwise, verification seems to loop *)
(*{ if "3.2.axioms" in queries["list"] or "3.2" in queries["list"] }*)
(*{ if "3.2.axioms" in queries["list"] }*) query (*{ else }*) axiom (*{ endif }*)
      chtk1,chtk2: chtoken,
      C_enc_k1,C_enc_k2,S_enc_k1,S_enc_k2: sekey, C_sign_k1, C_sign_k2, C_sign_k,S_sign_k, S_sign_k1,S_sign_k2: sskey,
      c_cert1,c_cert2,s_cert1,s_cert2: certificate, mode1,mode2: chmode, ch1,ch2: chid,
      C_pk1,C_pk2,S_pk1,S_pk2: pkey, id1,id2: seid, SAtoken, SAtoken1, SAtoken2: stoken, check1,check2: smode, usr1,usr2: login, U_tk1,U_tk2: utoken,
      er,er2: exponent, ger,ger2: G, S_nonce,S_nonce1,S_nonce2,S_nonce3: nonce, C_sk1,C_sk2:skey;

    let SK1 = keys(chtk1, C_enc_k1, C_sign_k, S_enc_k1, S_sign_k1) in
    let SK2 = keys(chtk1, C_enc_k2, C_sign_k, S_enc_k2, S_sign_k2) in
    let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
    let SC2 = chan(c_cert2, s_cert2, mode2, ch2, SK2) in

    event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1,  er, S_nonce1))
 && event(insert_C_sessions(C_pk2, S_pk2, id2, SAtoken2, check2, SC2, usr2, U_tk2, ger, S_nonce2, C_sk2))
==> ( SK1 = SK2 );

(* Matching client, server and session number => matching sessions *)
    let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k1) in
    let SK2 = keys(chtk2, C_enc_k2, C_sign_k2, S_enc_k2, S_sign_k2) in
    let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
    let SC2 = chan(c_cert2, s_cert2, mode2, ch2, SK2) in

    event(insert_C_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1, ger,  S_nonce1, C_sk1))
 && event(insert_C_sessions(C_pk1, S_pk1, id1, SAtoken2, check2, SC2, usr2, U_tk2, ger2, S_nonce2, C_sk2))
==> SAtoken1 = SAtoken2 && check1 = check2 && c_cert1 = c_cert2 && s_cert1 = s_cert2 && mode1 = mode2
  || event(leaked_server(S_pk1));


(* Matching client, server and session number => matching sessions *)
    let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k1) in
    let SK2 = keys(chtk2, C_enc_k2, C_sign_k2, S_enc_k2, S_sign_k2) in
    let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
    let SC2 = chan(c_cert2, s_cert2, mode2, ch2, SK2) in

    event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1, er,  S_nonce1))
 && event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken2, check2, SC2, usr2, U_tk2, er2, S_nonce2))
==> SAtoken1 = SAtoken2 && check1 = check2 && c_cert1 = c_cert2 && s_cert1 = s_cert2 && mode1 = mode2;

(* Matching session authentication token and symmetric keys ==> matching sessions *)
    let SK1 = keys(chtk1, C_enc_k1, C_sign_k1, S_enc_k1, S_sign_k1) in
    let SK2 = keys(chtk2, C_enc_k2, C_sign_k2, S_enc_k2, S_sign_k1) in
    let SC1 = chan(c_cert1, s_cert1, mode1, ch1, SK1) in
    let SC2 = chan(c_cert2, s_cert2, mode2, ch2, SK2) in

    event(insert_S_sessions(C_pk1, S_pk1, id1, SAtoken1, check1, SC1, usr1, U_tk1, er,  S_nonce1))
 && event(insert_S_sessions(C_pk2, S_pk2, id2, SAtoken1, check2, SC2, usr2, U_tk2, er2, S_nonce2))
==> SK1 = SK2 && mode1 = mode2 && c_cert1 = c_cert2 && s_cert1 = s_cert2 && id1 = id2 && check1 = check2.
(*{ endif }*)

(************************ END OF LEMMAS **********************************)


(**************** Main Process ****************)
(**********************************************)

process
  (* Anonymous user has no credential but is honest *)
  event honest(pk(sk_of(anonymous)));

  (* Create users *)
 !( new usr: login; out(c, usr);
    let U_pwd = pwd_of(usr) in
    let U_sk = sk_of(usr) in
    let U_pk = pk(U_sk) in event honest(U_pk);
    let U_cert = certify(user, any, U_pk) in out(c, U_cert);
    event new_user(usr, U_pwd, U_sk, U_pk, U_cert);
    insert users(usr, U_pwd, U_sk, U_cert);
   !(  in(c, U_tk: utoken) (*{ if queries["Sanity"] }*)[precise](*{ endif }*);
       if allowed_token(U_tk) then
       let (u: login, utk: utoken, upwd: psswrd, usk: skey, ucert: certificate) =
          if U_tk = user_anon
             then (anonymous, user_anon, no_pwd, no_skey, null_cert)
             else (usr, U_tk, U_pwd, U_sk, U_cert) in
       Activate_Session(u, utk, upwd, usk, ucert)
    )
  |!(  if switching_allowed() then
       in(c, U_tk: utoken);
       if allowed_token(U_tk) then
       let (u: login, utk: utoken, upwd: psswrd, usk: skey, ucert: certificate) =
       if U_tk = user_anon
           then (anonymous, user_anon, no_pwd, no_skey, null_cert)
           else (usr, U_tk, U_pwd, U_sk, U_cert) in
       Switch_Channel(u, utk, upwd, usk, ucert)
    )
  |!(User_Request(usr))
  | (if allowed_leak(lt_leaks) then event leaked(U_pk); out(c, (U_sk, U_pwd)))
  )

| (if allowed_token(user_anon) then !User_Request(anonymous)
  )

  (* Create OPC-UA Servers presenting RSA and ECC certificates *)
|!( new sk: skey;
    let S_pk = pk(sk) in event honest(S_pk);
    (*{ if "Conf[C]" in queries["list"] or "Conf[S]" in queries["list"] or "Conf[Pwd]" in queries["list"] }*)
    in(c, crypto: cryptography);
    in(c, check: smode)(*{ if "3.1.axioms" in queries["list"]}*)[precise](*{endif}*);
    in(c, (mode: chmode))
    (*{ if "Conf[S]" in queries["list"] or "3.1.axioms" in queries["list"]}*)[precise](*{endif}*);
    (* Refined the precise as highly costly: [precise]; for Conf[S] and 3.1.axioms *)
    (*{else}*)
    in(c, (crypto: cryptography, mode: chmode, check: smode)) [precise]; (* for Conf[S] and 3.1.axioms *)
    (*{endif}*)
    if allowed_crypto(crypto) && allowed_channel(mode) && allowed_session(check) then
    let S_cert = certify(server, crypto, S_pk) in out(c, S_cert);
   !Server(sk, S_cert, crypto, mode, check)
  | (if allowed_leak(lt_leaks) then event leaked(S_pk); event leaked_server(S_pk); out(c, sk))
  )

  (* Create OPC-UA Client Applications *)
|!( new sk: skey;
    let C_pk = pk(sk) in event honest(C_pk);
    in(c, crypto: cryptography);
    if allowed_crypto(crypto) then
    let C_cert = certify(client, crypto, C_pk) in out(c, C_cert);
    (* we let the attacker open channels and renew channel keys, and *)
    (* create sessions between applications, either checked or not.  *)
   !( in(c, (S_cert: certificate, mode: chmode, id: chid, check: smode));
      if get_kind(S_cert) = server && get_crypto(S_cert) = crypto &&
         allowed_channel(mode) && allowed_session(check)
      then Open_Channel_Create_Session(C_cert, S_cert, sk, mode, id, check)
    )
  | (if allowed_leak(lt_leaks) then event leaked(C_pk); out(c, sk))
  )